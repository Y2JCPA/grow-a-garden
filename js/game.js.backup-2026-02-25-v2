/* ============================================
   GROW A GARDEN 3D â€” Main Game (Three.js)
   ============================================ */
(function() {
'use strict';

// â”€â”€â”€ Constants â”€â”€â”€
const WORLD_SIZE = 64;
const PLOT_GRID = 4;       // 4x4 garden plots
const PLOT_SIZE = 2;       // each plot is 2x2 blocks
const PLOT_GAP = 1;        // gap between plots
const PLAYER_HEIGHT = 1.7;
const PLAYER_SPEED = 5;
const JUMP_FORCE = 7;
const GRAVITY = 18;
const INTERACT_DIST = 5;
const CAM_DISTANCE = 6;      // distance behind player
const CAM_HEIGHT_OFFSET = 3; // height above player
const PROFILES_KEY = 'garden3d_profiles';
const SAVE_PREFIX = 'garden3d_save_';
const MAX_PROFILES = 10;
const AUTO_SAVE_SEC = 10;
let activeProfileId = null;
function getSaveKey() { return SAVE_PREFIX + activeProfileId; }

// â”€â”€â”€ Game State â”€â”€â”€
let gameState = {
  coins: 100,
  inventory: { daisy: 3, sunflower: 2 },
  plots: [],       // {seedId, plantedAt, growTime, waterLevel}
  selectedSlot: 0,
  unlockedSkins: ['farmer'],
  waterCan: 100,          // watering can level (0-100)
  achievements: [],       // list of achievement IDs unlocked
  totalCoinsEarned: 0,    // lifetime coins for achievements
  totalHarvested: 0,      // lifetime harvests
  harvestedTypes: [],     // unique seed types harvested
  decorations: [],        // {type, x, z}
};

// â”€â”€â”€ Day/Night Cycle â”€â”€â”€
const DAY_CYCLE_DURATION = 300; // 5 real minutes = 1 game day
let dayTime = 0.25; // start at morning (0=midnight, 0.25=dawn, 0.5=noon, 0.75=dusk)
let currentWeather = 'sunny'; // sunny, cloudy, rainy
let weatherTimer = 0;
let sunLight = null;
let ambientLight = null;
let hemiLight = null;

// â”€â”€â”€ Pet Dog â”€â”€â”€
let dogModel = null;
let dogPos = new THREE.Vector3(3, 0, 3);
let dogTargetPos = new THREE.Vector3(3, 0, 3);
let dogWalkCycle = 0;
let dogBarkTimer = 30 + Math.random() * 30;
let dogWanderTimer = 5;
const DOG_SPEED = 2.5;
const DOG_INTERACT_DIST = 2.5;
let nearDog = false;

// â”€â”€â”€ Ambient Creatures â”€â”€â”€
let butterflies = [];
let birds = [];
let fireflies = [];

// â”€â”€â”€ Rain Particles â”€â”€â”€
let rainParticles = null;
let rainDrops = [];

// â”€â”€â”€ Three.js globals â”€â”€â”€
let scene, camera, renderer, clock;
let playerVelocity = new THREE.Vector3();
let playerOnGround = true;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, jumping = false;
let isPointerLocked = false;
let yaw = 0, pitch = 0;
let raycaster, interactTarget = null;
let plotMeshes = [];      // {group, plotIndex, soilMesh, plantMesh, stage}
let cloudMeshes = [];
let particlePool = [];
let playerModel = null;  // third-person blocky character
let shopkeeperModel = null; // Shlomo the seed seller
const SHOPKEEPER_POS = { x: -10, z: -2 }; // off to the left of the garden
const SHOPKEEPER_INTERACT_DIST = 4;
let nearShopkeeper = false;
let started = false;
let autoSaveTimer = 0;
let touchMoveVec = {x: 0, y: 0};
let isMobile = false;
let animating = false;
let startBtnBound = false;

// â”€â”€â”€ DOM refs â”€â”€â”€
const $ = sel => document.querySelector(sel);
const coinAmountEl = $('#coin-amount');
const interactPromptEl = $('#interact-prompt');
const plotLabelEl = $('#plot-label');
const hotbarEl = $('#hotbar');
const toastContainer = $('#toast-container');
const startScreen = $('#start-screen');
const startBtn = $('#start-btn');

// â”€â”€â”€ Utility â”€â”€â”€
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

function showToast(icon, text) {
  const t = document.createElement('div');
  t.className = 'toast';
  t.innerHTML = `<span class="toast-icon">${icon}</span><span class="toast-text">${text}</span>`;
  toastContainer.appendChild(t);
  setTimeout(() => { t.classList.add('exiting'); setTimeout(() => t.remove(), 300); }, 2500);
}

function spawnParticles(screenX, screenY, emoji, count) {
  for (let i = 0; i < count; i++) {
    const p = document.createElement('span');
    p.className = 'harvest-particle';
    p.textContent = emoji;
    const angle = (Math.PI * 2 * i) / count;
    const dist = 40 + Math.random() * 60;
    p.style.left = screenX + 'px';
    p.style.top = screenY + 'px';
    p.style.setProperty('--dx', Math.cos(angle) * dist + 'px');
    p.style.setProperty('--dy', (Math.sin(angle) * dist - 30) + 'px');
    document.body.appendChild(p);
    setTimeout(() => p.remove(), 800);
  }
}

function spawnCoinFly() {
  const rect = coinAmountEl.getBoundingClientRect();
  const c = document.createElement('span');
  c.className = 'coin-fly';
  c.textContent = 'ðŸª™';
  c.style.left = (rect.left + rect.width/2) + 'px';
  c.style.top = rect.top + 'px';
  document.body.appendChild(c);
  setTimeout(() => c.remove(), 700);
}

// â”€â”€â”€ Init Plots State â”€â”€â”€
function initPlots() {
  gameState.plots = [];
  for (let i = 0; i < PLOT_GRID * PLOT_GRID; i++) {
    gameState.plots.push(null); // null = empty
  }
}

// â”€â”€â”€ Plot world positions â”€â”€â”€
function getPlotWorldPos(index) {
  const row = Math.floor(index / PLOT_GRID);
  const col = index % PLOT_GRID;
  const totalSpan = PLOT_GRID * PLOT_SIZE + (PLOT_GRID - 1) * PLOT_GAP;
  const startX = -totalSpan / 2 + PLOT_SIZE / 2;
  const startZ = -totalSpan / 2 + PLOT_SIZE / 2;
  return {
    x: startX + col * (PLOT_SIZE + PLOT_GAP),
    z: startZ + row * (PLOT_SIZE + PLOT_GAP),
  };
}

// â”€â”€â”€ Three.js Scene Setup â”€â”€â”€
function initScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 30, 60);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, PLAYER_HEIGHT + CAM_HEIGHT_OFFSET, CAM_DISTANCE);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.insertBefore(renderer.domElement, document.body.firstChild);

  clock = new THREE.Clock();
  raycaster = new THREE.Raycaster();
  raycaster.far = INTERACT_DIST;

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

// â”€â”€â”€ Lighting â”€â”€â”€
function initLighting() {
  ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  sunLight = new THREE.DirectionalLight(0xfff4cc, 1.2);
  sunLight.position.set(10, 20, 8);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.camera.near = 0.5;
  sunLight.shadow.camera.far = 100;
  sunLight.shadow.camera.left = -40;
  sunLight.shadow.camera.right = 40;
  sunLight.shadow.camera.top = 40;
  sunLight.shadow.camera.bottom = -40;
  scene.add(sunLight);

  hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x556B2F, 0.3);
  scene.add(hemiLight);
}

// â”€â”€â”€ World Building â”€â”€â”€
function buildWorld() {
  // Ground plane (large grass area)
  const grassGeo = new THREE.BoxGeometry(WORLD_SIZE, 0.5, WORLD_SIZE);
  const grassMat = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
  const ground = new THREE.Mesh(grassGeo, grassMat);
  ground.position.set(0, -0.25, 0);
  ground.receiveShadow = true;
  ground.name = 'ground';
  scene.add(ground);

  // Darker green top detail patches
  for (let i = 0; i < 160; i++) {
    const patchGeo = new THREE.BoxGeometry(1 + Math.random() * 3, 0.05, 1 + Math.random() * 3);
    const patchMat = new THREE.MeshLambertMaterial({ color: Math.random() > 0.5 ? 0x388E3C : 0x66BB6A });
    const patch = new THREE.Mesh(patchGeo, patchMat);
    patch.position.set(
      (Math.random() - 0.5) * WORLD_SIZE * 0.9,
      0.01,
      (Math.random() - 0.5) * WORLD_SIZE * 0.9
    );
    patch.receiveShadow = true;
    scene.add(patch);
  }

  // Garden area border (fence)
  const gardenSpan = PLOT_GRID * PLOT_SIZE + (PLOT_GRID - 1) * PLOT_GAP + 2;
  const fenceMat = new THREE.MeshLambertMaterial({ color: 0x8D6E63 });
  const fenceHeight = 1;
  const fenceThick = 0.2;
  const half = gardenSpan / 2;

  // Fence posts and rails
  const postGeo = new THREE.BoxGeometry(0.3, fenceHeight, 0.3);
  const railGeo = new THREE.BoxGeometry(fenceThick, 0.15, gardenSpan + 0.3);
  const railGeoX = new THREE.BoxGeometry(gardenSpan + 0.3, 0.15, fenceThick);

  // Posts at corners and midpoints
  const postPositions = [];
  for (let i = 0; i <= PLOT_GRID; i++) {
    const t = -half + i * (gardenSpan / PLOT_GRID);
    postPositions.push([t, -half], [t, half], [-half, t], [half, t]);
  }
  const seen = new Set();
  postPositions.forEach(([x, z]) => {
    const key = `${x.toFixed(1)}_${z.toFixed(1)}`;
    if (seen.has(key)) return;
    seen.add(key);
    const post = new THREE.Mesh(postGeo, fenceMat);
    post.position.set(x, fenceHeight / 2, z);
    post.castShadow = true;
    scene.add(post);
  });

  // Rails on each side
  [[-half, 0], [half, 0]].forEach(([x]) => {
    for (let h = 0.3; h <= 0.8; h += 0.5) {
      const rail = new THREE.Mesh(railGeo, fenceMat);
      rail.position.set(x, h, 0);
      rail.castShadow = true;
      scene.add(rail);
    }
  });
  [[0, -half], [0, half]].forEach(([, z]) => {
    for (let h = 0.3; h <= 0.8; h += 0.5) {
      const rail = new THREE.Mesh(railGeoX, fenceMat);
      rail.position.set(0, h, z);
      rail.castShadow = true;
      scene.add(rail);
    }
  });

  // Clouds
  const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 });
  for (let i = 0; i < 12; i++) {
    const cg = new THREE.Group();
    const numBlocks = 3 + Math.floor(Math.random() * 4);
    for (let b = 0; b < numBlocks; b++) {
      const w = 1.5 + Math.random() * 2;
      const h = 0.6 + Math.random() * 0.5;
      const d = 1.5 + Math.random() * 2;
      const block = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), cloudMat);
      block.position.set(b * 1.2 - numBlocks * 0.6, Math.random() * 0.3, Math.random() * 0.5);
      cg.add(block);
    }
    cg.position.set(
      (Math.random() - 0.5) * 50,
      14 + Math.random() * 6,
      (Math.random() - 0.5) * 50
    );
    scene.add(cg);
    cloudMeshes.push(cg);
  }

  // Decorative trees/bushes outside garden
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x6D4C41 });
  const leavesMat = new THREE.MeshLambertMaterial({ color: 0x2E7D32 });
  for (let i = 0; i < 40; i++) {
    const angle = (Math.PI * 2 * i) / 40;
    const dist = 14 + Math.random() * 28;
    const tx = Math.cos(angle) * dist;
    const tz = Math.sin(angle) * dist;

    const trunk = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2, 0.5), trunkMat);
    trunk.position.set(tx, 1, tz);
    trunk.castShadow = true;
    scene.add(trunk);

    const leaves = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), leavesMat);
    leaves.position.set(tx, 3, tz);
    leaves.castShadow = true;
    scene.add(leaves);

    if (Math.random() > 0.5) {
      const leaves2 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), leavesMat);
      leaves2.position.set(tx + 0.5, 3.8, tz + 0.3);
      scene.add(leaves2);
    }
  }
}

// â”€â”€â”€ Player Character Model (blocky Minecraft-style) â”€â”€â”€
function buildPlayerModel() {
  if (playerModel) scene.remove(playerModel);
  playerModel = new THREE.Group();

  // Get skin from active profile
  const profiles = getProfiles();
  const prof = profiles.find(p => p.id === activeProfileId);
  const skin = (prof && prof.skin) || DEFAULT_SKIN;

  if (skin === 'ninja') {
    buildNinjaSkin(playerModel);
  } else if (skin === 'sonic') {
    buildSonicSkin(playerModel);
  } else {
    buildFarmerSkin(playerModel);
  }

  playerModel.position.set(0, 0, 0);
  scene.add(playerModel);
}

function buildFarmerSkin(model) {
  const skinColor = 0xD2A87A;
  const shirtColor = 0x4CAF50;
  const pantsColor = 0x5D4037;
  const shoeColor = 0x333333;
  const hatColor = 0x8B4513;

  // Head
  const head = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.5, 0.5),
    new THREE.MeshLambertMaterial({ color: skinColor })
  );
  head.position.y = 1.55;
  head.castShadow = true;
  model.add(head);

  // Eyes (on FRONT of face, +z)
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
  const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), eyeMat);
  eyeL.position.set(-0.12, 1.6, 0.25);
  model.add(eyeL);
  const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), eyeMat);
  eyeR.position.set(0.12, 1.6, 0.25);
  model.add(eyeR);

  // Hat (farmer\'s hat)
  const hatBrim = new THREE.Mesh(
    new THREE.BoxGeometry(0.8, 0.06, 0.8),
    new THREE.MeshLambertMaterial({ color: hatColor })
  );
  hatBrim.position.y = 1.82;
  hatBrim.castShadow = true;
  model.add(hatBrim);
  const hatTop = new THREE.Mesh(
    new THREE.BoxGeometry(0.45, 0.25, 0.45),
    new THREE.MeshLambertMaterial({ color: hatColor })
  );
  hatTop.position.y = 1.95;
  hatTop.castShadow = true;
  model.add(hatTop);

  // Body (shirt)
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.6, 0.3),
    new THREE.MeshLambertMaterial({ color: shirtColor })
  );
  body.position.y = 1.0;
  body.castShadow = true;
  model.add(body);

  // Arms
  const armGeo = new THREE.BoxGeometry(0.2, 0.55, 0.2);
  const armMat = new THREE.MeshLambertMaterial({ color: shirtColor });
  const armL = new THREE.Mesh(armGeo, armMat);
  armL.position.set(-0.35, 1.0, 0);
  armL.castShadow = true;
  model.add(armL);
  const armR = new THREE.Mesh(armGeo, armMat);
  armR.position.set(0.35, 1.0, 0);
  armR.castShadow = true;
  model.add(armR);

  // Hands (skin)
  const handGeo = new THREE.BoxGeometry(0.18, 0.15, 0.18);
  const handMat = new THREE.MeshLambertMaterial({ color: skinColor });
  const handL = new THREE.Mesh(handGeo, handMat);
  handL.position.set(-0.35, 0.66, 0);
  model.add(handL);
  const handR = new THREE.Mesh(handGeo, handMat);
  handR.position.set(0.35, 0.66, 0);
  model.add(handR);

  // Legs (pants)
  const legGeo = new THREE.BoxGeometry(0.22, 0.5, 0.25);
  const legMat = new THREE.MeshLambertMaterial({ color: pantsColor });
  const legL = new THREE.Mesh(legGeo, legMat);
  legL.position.set(-0.13, 0.45, 0);
  legL.castShadow = true;
  model.add(legL);
  const legR = new THREE.Mesh(legGeo, legMat);
  legR.position.set(0.13, 0.45, 0);
  legR.castShadow = true;
  model.add(legR);

  // Shoes
  const shoeGeo = new THREE.BoxGeometry(0.22, 0.1, 0.32);
  const shoeMat = new THREE.MeshLambertMaterial({ color: shoeColor });
  const shoeL = new THREE.Mesh(shoeGeo, shoeMat);
  shoeL.position.set(-0.13, 0.15, -0.03);
  model.add(shoeL);
  const shoeR = new THREE.Mesh(shoeGeo, shoeMat);
  shoeR.position.set(0.13, 0.15, -0.03);
  model.add(shoeR);

  model.userData = { armL, armR, legL, legR };
}

function buildNinjaSkin(model) {
  const ninjaBlack = 0x1a1a2e;
  const ninjaDark = 0x16213e;
  const beltColor = 0x8B0000;
  const skinColor = 0xD2A87A;

  // Head (masked)
  const head = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.5, 0.5),
    new THREE.MeshLambertMaterial({ color: ninjaBlack })
  );
  head.position.y = 1.55;
  head.castShadow = true;
  model.add(head);

  // Eyes (narrow, glowing)
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
  const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.05, 0.05), eyeMat);
  eyeL.position.set(-0.12, 1.6, 0.26);
  model.add(eyeL);
  const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.05, 0.05), eyeMat);
  eyeR.position.set(0.12, 1.6, 0.26);
  model.add(eyeR);

  // Headband (red)
  const headband = new THREE.Mesh(
    new THREE.BoxGeometry(0.55, 0.08, 0.55),
    new THREE.MeshLambertMaterial({ color: beltColor })
  );
  headband.position.y = 1.68;
  model.add(headband);

  // Headband tail (two strips hanging back)
  const tailMat = new THREE.MeshLambertMaterial({ color: beltColor });
  const tailL = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.03, 0.35), tailMat);
  tailL.position.set(-0.1, 1.66, -0.4);
  model.add(tailL);
  const tailR = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.03, 0.35), tailMat);
  tailR.position.set(0.06, 1.68, -0.45);
  model.add(tailR);

  // Body (ninja gi)
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.6, 0.3),
    new THREE.MeshLambertMaterial({ color: ninjaDark })
  );
  body.position.y = 1.0;
  body.castShadow = true;
  model.add(body);

  // Belt
  const belt = new THREE.Mesh(
    new THREE.BoxGeometry(0.52, 0.08, 0.32),
    new THREE.MeshLambertMaterial({ color: beltColor })
  );
  belt.position.y = 0.75;
  model.add(belt);

  // Arms
  const armGeo = new THREE.BoxGeometry(0.2, 0.55, 0.2);
  const armMat = new THREE.MeshLambertMaterial({ color: ninjaDark });
  const armL = new THREE.Mesh(armGeo, armMat);
  armL.position.set(-0.35, 1.0, 0);
  armL.castShadow = true;
  model.add(armL);
  const armR = new THREE.Mesh(armGeo, armMat);
  armR.position.set(0.35, 1.0, 0);
  armR.castShadow = true;
  model.add(armR);

  // Hands (skin showing through wraps)
  const handGeo = new THREE.BoxGeometry(0.18, 0.15, 0.18);
  const handMat = new THREE.MeshLambertMaterial({ color: skinColor });
  const handL = new THREE.Mesh(handGeo, handMat);
  handL.position.set(-0.35, 0.66, 0);
  model.add(handL);
  const handR = new THREE.Mesh(handGeo, handMat);
  handR.position.set(0.35, 0.66, 0);
  model.add(handR);

  // Sword on back (diagonal)
  const swordBlade = new THREE.Mesh(
    new THREE.BoxGeometry(0.06, 0.8, 0.03),
    new THREE.MeshLambertMaterial({ color: 0xC0C0C0 })
  );
  swordBlade.position.set(0.1, 1.4, -0.2);
  swordBlade.rotation.z = 0.3;
  model.add(swordBlade);
  const swordHandle = new THREE.Mesh(
    new THREE.BoxGeometry(0.08, 0.2, 0.05),
    new THREE.MeshLambertMaterial({ color: 0x5D4037 })
  );
  swordHandle.position.set(0.22, 1.85, -0.2);
  swordHandle.rotation.z = 0.3;
  model.add(swordHandle);

  // Legs
  const legGeo = new THREE.BoxGeometry(0.22, 0.5, 0.25);
  const legMat = new THREE.MeshLambertMaterial({ color: ninjaBlack });
  const legL = new THREE.Mesh(legGeo, legMat);
  legL.position.set(-0.13, 0.45, 0);
  legL.castShadow = true;
  model.add(legL);
  const legR = new THREE.Mesh(legGeo, legMat);
  legR.position.set(0.13, 0.45, 0);
  legR.castShadow = true;
  model.add(legR);

  // Tabi boots
  const shoeGeo = new THREE.BoxGeometry(0.22, 0.1, 0.32);
  const shoeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const shoeL = new THREE.Mesh(shoeGeo, shoeMat);
  shoeL.position.set(-0.13, 0.15, -0.03);
  model.add(shoeL);
  const shoeR = new THREE.Mesh(shoeGeo, shoeMat);
  shoeR.position.set(0.13, 0.15, -0.03);
  model.add(shoeR);

  model.userData = { armL, armR, legL, legR };
}

function buildSonicSkin(model) {
  const sonicBlue = 0x1565C0;
  const skinColor = 0xFFCC80;
  const shoeRed = 0xD32F2F;
  const gloveWhite = 0xFFFFFF;

  // Head (blue, rounder)
  const head = new THREE.Mesh(
    new THREE.BoxGeometry(0.55, 0.5, 0.5),
    new THREE.MeshLambertMaterial({ color: sonicBlue })
  );
  head.position.y = 1.55;
  head.castShadow = true;
  model.add(head);

  // Face (tan belly color on front)
  const face = new THREE.Mesh(
    new THREE.BoxGeometry(0.35, 0.35, 0.05),
    new THREE.MeshLambertMaterial({ color: skinColor })
  );
  face.position.set(0, 1.53, 0.26);
  model.add(face);

  // Eyes (big green)
  const eyeWhiteL = new THREE.Mesh(
    new THREE.BoxGeometry(0.14, 0.18, 0.05),
    new THREE.MeshLambertMaterial({ color: 0xFFFFFF })
  );
  eyeWhiteL.position.set(-0.08, 1.6, 0.29);
  model.add(eyeWhiteL);
  const eyeWhiteR = new THREE.Mesh(
    new THREE.BoxGeometry(0.14, 0.18, 0.05),
    new THREE.MeshLambertMaterial({ color: 0xFFFFFF })
  );
  eyeWhiteR.position.set(0.08, 1.6, 0.29);
  model.add(eyeWhiteR);
  const pupilMat = new THREE.MeshLambertMaterial({ color: 0x2E7D32 });
  const pupilL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.05), pupilMat);
  pupilL.position.set(-0.06, 1.59, 0.32);
  model.add(pupilL);
  const pupilR = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.05), pupilMat);
  pupilR.position.set(0.1, 1.59, 0.32);
  model.add(pupilR);

  // Spikes (3 blue quills going back)
  const spikeMat = new THREE.MeshLambertMaterial({ color: sonicBlue });
  for (let i = 0; i < 3; i++) {
    const spike = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.12, 0.5),
      spikeMat
    );
    spike.position.set(0, 1.65 - i * 0.15, -0.45 - i * 0.1);
    spike.rotation.x = -0.3;
    model.add(spike);
  }

  // Ears (two blue triangular blocks on top)
  const earL = new THREE.Mesh(
    new THREE.BoxGeometry(0.1, 0.2, 0.1),
    new THREE.MeshLambertMaterial({ color: sonicBlue })
  );
  earL.position.set(-0.22, 1.82, 0.05);
  model.add(earL);
  const earR = new THREE.Mesh(
    new THREE.BoxGeometry(0.1, 0.2, 0.1),
    new THREE.MeshLambertMaterial({ color: sonicBlue })
  );
  earR.position.set(0.22, 1.82, 0.05);
  model.add(earR);

  // Body (blue with tan belly)
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.45, 0.55, 0.3),
    new THREE.MeshLambertMaterial({ color: sonicBlue })
  );
  body.position.y = 1.0;
  body.castShadow = true;
  model.add(body);
  const belly = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 0.4, 0.05),
    new THREE.MeshLambertMaterial({ color: skinColor })
  );
  belly.position.set(0, 1.0, 0.16);
  model.add(belly);

  // Arms (blue)
  const armGeo = new THREE.BoxGeometry(0.18, 0.5, 0.18);
  const armMat = new THREE.MeshLambertMaterial({ color: sonicBlue });
  const armL = new THREE.Mesh(armGeo, armMat);
  armL.position.set(-0.33, 1.0, 0);
  armL.castShadow = true;
  model.add(armL);
  const armR = new THREE.Mesh(armGeo, armMat);
  armR.position.set(0.33, 1.0, 0);
  armR.castShadow = true;
  model.add(armR);

  // White gloves
  const handGeo = new THREE.BoxGeometry(0.22, 0.18, 0.22);
  const handMat = new THREE.MeshLambertMaterial({ color: gloveWhite });
  const handL = new THREE.Mesh(handGeo, handMat);
  handL.position.set(-0.33, 0.68, 0);
  model.add(handL);
  const handR = new THREE.Mesh(handGeo, handMat);
  handR.position.set(0.33, 0.68, 0);
  model.add(handR);

  // Legs (blue, shorter)
  const legGeo = new THREE.BoxGeometry(0.2, 0.4, 0.22);
  const legMat = new THREE.MeshLambertMaterial({ color: sonicBlue });
  const legL = new THREE.Mesh(legGeo, legMat);
  legL.position.set(-0.12, 0.48, 0);
  legL.castShadow = true;
  model.add(legL);
  const legR = new THREE.Mesh(legGeo, legMat);
  legR.position.set(0.12, 0.48, 0);
  legR.castShadow = true;
  model.add(legR);

  // Red shoes with white stripe
  const shoeGeo = new THREE.BoxGeometry(0.24, 0.14, 0.36);
  const shoeMat = new THREE.MeshLambertMaterial({ color: shoeRed });
  const shoeL = new THREE.Mesh(shoeGeo, shoeMat);
  shoeL.position.set(-0.12, 0.22, 0);
  model.add(shoeL);
  const shoeR = new THREE.Mesh(shoeGeo, shoeMat);
  shoeR.position.set(0.12, 0.22, 0);
  model.add(shoeR);
  // White stripe on shoes
  const stripeMat = new THREE.MeshLambertMaterial({ color: gloveWhite });
  const stripeL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.04, 0.37), stripeMat);
  stripeL.position.set(-0.12, 0.22, 0);
  model.add(stripeL);
  const stripeR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.04, 0.37), stripeMat);
  stripeR.position.set(0.12, 0.22, 0);
  model.add(stripeR);

  model.userData = { armL, armR, legL, legR };
}

// â”€â”€â”€ Shopkeeper NPC: Shlomo â”€â”€â”€
function buildShopkeeper() {
  if (shopkeeperModel) scene.remove(shopkeeperModel);
  shopkeeperModel = new THREE.Group();

  const skinColor = 0xC8956C;
  const apronColor = 0xD32F2F;  // red apron
  const shirtColor = 0xFFF9C4;  // cream shirt
  const pantsColor = 0x37474F;
  const hatColor = 0x4E342E;
  const standWood = 0x8D6E63;
  const standTop = 0x5D4037;
  const canopyColor = 0xC62828;
  const canopyStripe = 0xEF9A9A;

  // â”€â”€ Stand / Market stall â”€â”€
  // Counter
  const counter = new THREE.Mesh(
    new THREE.BoxGeometry(3, 0.15, 1.2),
    new THREE.MeshLambertMaterial({ color: standTop })
  );
  counter.position.set(0, 1.0, -1.2);
  counter.castShadow = true;
  shopkeeperModel.add(counter);

  // Counter legs
  const legGeo = new THREE.BoxGeometry(0.15, 1.0, 0.15);
  const legMat = new THREE.MeshLambertMaterial({ color: standWood });
  [[-1.3, -1.7], [-1.3, -0.7], [1.3, -1.7], [1.3, -0.7]].forEach(([x, z]) => {
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.position.set(x, 0.5, z);
    leg.castShadow = true;
    shopkeeperModel.add(leg);
  });

  // Canopy poles
  const poleGeo = new THREE.BoxGeometry(0.12, 2.5, 0.12);
  const poleMat = new THREE.MeshLambertMaterial({ color: standWood });
  [[-1.4, -1.8], [1.4, -1.8], [-1.4, -0.6], [1.4, -0.6]].forEach(([x, z]) => {
    const pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.set(x, 1.25, z);
    pole.castShadow = true;
    shopkeeperModel.add(pole);
  });

  // Canopy (striped awning)
  const canopyGeo = new THREE.BoxGeometry(3.2, 0.1, 1.8);
  const canopy = new THREE.Mesh(canopyGeo, new THREE.MeshLambertMaterial({ color: canopyColor }));
  canopy.position.set(0, 2.55, -1.2);
  canopy.castShadow = true;
  shopkeeperModel.add(canopy);

  // Canopy stripes
  for (let i = -1; i <= 1; i++) {
    const stripe = new THREE.Mesh(
      new THREE.BoxGeometry(0.5, 0.12, 1.85),
      new THREE.MeshLambertMaterial({ color: canopyStripe })
    );
    stripe.position.set(i * 1.0, 2.56, -1.2);
    shopkeeperModel.add(stripe);
  }

  // Seed display items on counter (decorative)
  const displaySeeds = ['ðŸŒ»', 'ðŸŒ¹', 'ðŸŒ·'];
  const seedColors = [0xFFD600, 0xE91E63, 0xFF5722];
  seedColors.forEach((col, i) => {
    const seedBag = new THREE.Mesh(
      new THREE.BoxGeometry(0.35, 0.3, 0.25),
      new THREE.MeshLambertMaterial({ color: col })
    );
    seedBag.position.set(-0.8 + i * 0.8, 1.25, -1.2);
    seedBag.castShadow = true;
    shopkeeperModel.add(seedBag);
  });

  // Sign
  const signBoard = new THREE.Mesh(
    new THREE.BoxGeometry(2.0, 0.5, 0.08),
    new THREE.MeshLambertMaterial({ color: 0xFFF8E1 })
  );
  signBoard.position.set(0, 2.95, -1.2);
  shopkeeperModel.add(signBoard);

  // â”€â”€ Shlomo (the shopkeeper) â”€â”€
  // Head
  const head = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.5, 0.5),
    new THREE.MeshLambertMaterial({ color: skinColor })
  );
  head.position.y = 1.55;
  head.castShadow = true;
  shopkeeperModel.add(head);

  // Big smile (mouth)
  const mouth = new THREE.Mesh(
    new THREE.BoxGeometry(0.2, 0.06, 0.05),
    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
  );
  mouth.position.set(0, 1.42, -0.25);
  shopkeeperModel.add(mouth);

  // Eyes
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
  const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.05), eyeMat);
  eyeL.position.set(-0.12, 1.58, -0.25);
  shopkeeperModel.add(eyeL);
  const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.05), eyeMat);
  eyeR.position.set(0.12, 1.58, -0.25);
  shopkeeperModel.add(eyeR);

  // Straw hat
  const brim = new THREE.Mesh(
    new THREE.BoxGeometry(0.9, 0.06, 0.9),
    new THREE.MeshLambertMaterial({ color: 0xF9A825 })
  );
  brim.position.y = 1.82;
  shopkeeperModel.add(brim);
  const top = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.3, 0.5),
    new THREE.MeshLambertMaterial({ color: 0xF9A825 })
  );
  top.position.y = 1.98;
  shopkeeperModel.add(top);
  // Hat band
  const band = new THREE.Mesh(
    new THREE.BoxGeometry(0.52, 0.08, 0.52),
    new THREE.MeshLambertMaterial({ color: apronColor })
  );
  band.position.y = 1.87;
  shopkeeperModel.add(band);

  // Body (cream shirt)
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.6, 0.3),
    new THREE.MeshLambertMaterial({ color: shirtColor })
  );
  body.position.y = 1.0;
  body.castShadow = true;
  shopkeeperModel.add(body);

  // Apron
  const apron = new THREE.Mesh(
    new THREE.BoxGeometry(0.4, 0.5, 0.05),
    new THREE.MeshLambertMaterial({ color: apronColor })
  );
  apron.position.set(0, 0.95, -0.18);
  shopkeeperModel.add(apron);

  // Arms
  const armGeo = new THREE.BoxGeometry(0.2, 0.55, 0.2);
  const armMat = new THREE.MeshLambertMaterial({ color: shirtColor });
  const armL = new THREE.Mesh(armGeo, armMat);
  armL.position.set(-0.35, 1.0, 0);
  armL.castShadow = true;
  shopkeeperModel.add(armL);
  const armR = new THREE.Mesh(armGeo, armMat);
  armR.position.set(0.35, 1.0, 0);
  armR.rotation.x = -0.3; // reaching forward toward counter
  armR.castShadow = true;
  shopkeeperModel.add(armR);

  // Hands
  const handGeo = new THREE.BoxGeometry(0.18, 0.15, 0.18);
  const handMat = new THREE.MeshLambertMaterial({ color: skinColor });
  const handL = new THREE.Mesh(handGeo, handMat);
  handL.position.set(-0.35, 0.66, 0);
  shopkeeperModel.add(handL);
  const handR = new THREE.Mesh(handGeo, handMat);
  handR.position.set(0.35, 0.72, -0.15);
  shopkeeperModel.add(handR);

  // Legs
  const legGeo2 = new THREE.BoxGeometry(0.22, 0.5, 0.25);
  const legMat2 = new THREE.MeshLambertMaterial({ color: pantsColor });
  const legL = new THREE.Mesh(legGeo2, legMat2);
  legL.position.set(-0.13, 0.45, 0);
  shopkeeperModel.add(legL);
  const legR = new THREE.Mesh(legGeo2, legMat2);
  legR.position.set(0.13, 0.45, 0);
  shopkeeperModel.add(legR);

  // Shoes
  const shoeGeo = new THREE.BoxGeometry(0.22, 0.1, 0.32);
  const shoeMat = new THREE.MeshLambertMaterial({ color: 0x5D4037 });
  const shoeL = new THREE.Mesh(shoeGeo, shoeMat);
  shoeL.position.set(-0.13, 0.15, -0.03);
  shopkeeperModel.add(shoeL);
  const shoeR = new THREE.Mesh(shoeGeo, shoeMat);
  shoeR.position.set(0.13, 0.15, -0.03);
  shopkeeperModel.add(shoeR);

  // Position the whole group â€” Shlomo stands behind the counter facing the garden
  shopkeeperModel.position.set(SHOPKEEPER_POS.x, 0, SHOPKEEPER_POS.z);
  shopkeeperModel.rotation.y = Math.PI * 0.5; // face right toward garden
  scene.add(shopkeeperModel);
}

// â”€â”€â”€ Garden Plots (3D) â”€â”€â”€
function buildGardenPlots() {
  plotMeshes.forEach(pm => scene.remove(pm.group));
  plotMeshes = [];

  const soilMat = new THREE.MeshLambertMaterial({ color: 0x5D4037 });
  const soilTopMat = new THREE.MeshLambertMaterial({ color: 0x6D4C41 });

  for (let i = 0; i < PLOT_GRID * PLOT_GRID; i++) {
    const pos = getPlotWorldPos(i);
    const group = new THREE.Group();
    group.position.set(pos.x, 0, pos.z);

    // Soil block
    const soilGeo = new THREE.BoxGeometry(PLOT_SIZE - 0.1, 0.3, PLOT_SIZE - 0.1);
    const soil = new THREE.Mesh(soilGeo, soilMat);
    soil.position.y = 0.15;
    soil.receiveShadow = true;
    soil.castShadow = true;
    group.add(soil);

    // Soil top (tilled look)
    const topGeo = new THREE.BoxGeometry(PLOT_SIZE - 0.2, 0.05, PLOT_SIZE - 0.2);
    const top = new THREE.Mesh(topGeo, soilTopMat);
    top.position.y = 0.31;
    top.receiveShadow = true;
    group.add(top);

    // Tilled rows
    const rowMat = new THREE.MeshLambertMaterial({ color: 0x4E342E });
    for (let r = -0.6; r <= 0.6; r += 0.4) {
      const rowGeo = new THREE.BoxGeometry(PLOT_SIZE - 0.4, 0.04, 0.12);
      const row = new THREE.Mesh(rowGeo, rowMat);
      row.position.set(0, 0.33, r);
      group.add(row);
    }

    scene.add(group);
    plotMeshes.push({
      group,
      plotIndex: i,
      soilMesh: soil,
      plantMesh: null,
      glowMesh: null,
    });
  }
}

// â”€â”€â”€ Plant Model Builders â”€â”€â”€
function buildPlantModel(seedId, seed, progress, isReady) {
  const g = new THREE.Group();
  const baseY = 0.32;
  const h = 0.15 + progress * 1.0; // overall height scale
  const plantColor = isReady ? seed.color : lerpColor(0x8BC34A, seed.color, progress);
  const topColor = isReady ? (seed.topColor || seed.color) : lerpColor(0x8BC34A, seed.topColor || seed.color, progress);
  const stemColor = 0x33691E;
  const leafColor = 0x4CAF50;

  // Helper to add a box mesh
  function box(w, bh, d, color, x, y, z) {
    const m = new THREE.Mesh(new THREE.BoxGeometry(w, bh, d), new THREE.MeshLambertMaterial({ color }));
    m.position.set(x, y, z);
    m.castShadow = true;
    g.add(m);
    return m;
  }

  switch (seedId) {
    // â”€â”€â”€ FLOWERS â”€â”€â”€
    case 'daisy':
    case 'lavender': {
      // Thin stem + flat wide petals on top
      box(0.1, h * 0.7, 0.1, stemColor, 0, baseY + h * 0.35, 0);
      const petalY = baseY + h * 0.7;
      const ps = 0.15 + progress * 0.15;
      box(ps * 3, 0.08, ps, plantColor, 0, petalY, 0); // horizontal petals
      box(ps, 0.08, ps * 3, plantColor, 0, petalY, 0); // cross petals
      box(ps * 2, 0.08, ps * 2, plantColor, 0, petalY, 0); // diagonal fill
      if (progress > 0.5) box(0.12, 0.12, 0.12, topColor, 0, petalY + 0.08, 0); // center
      break;
    }

    case 'sunflower': {
      // Tall thick stem + big round-ish head
      box(0.18, h * 0.8, 0.18, stemColor, 0, baseY + h * 0.4, 0);
      if (progress > 0.3) { // leaves
        box(0.35, 0.06, 0.15, leafColor, 0.2, baseY + h * 0.25, 0);
        box(0.35, 0.06, 0.15, leafColor, -0.2, baseY + h * 0.4, 0);
      }
      const headY = baseY + h * 0.8;
      const hs = 0.3 + progress * 0.35;
      box(hs, hs * 0.3, hs, plantColor, 0, headY, 0); // petals
      box(hs * 0.6, hs * 0.35, hs * 0.6, 0x5D3A1A, 0, headY, 0); // dark center
      break;
    }

    case 'rose': {
      // Thorny stem + layered bud
      box(0.1, h * 0.65, 0.1, 0x2E5E1E, 0, baseY + h * 0.32, 0);
      if (progress > 0.2) box(0.06, 0.06, 0.15, 0x2E5E1E, 0.08, baseY + h * 0.2, 0); // thorn
      if (progress > 0.35) box(0.06, 0.06, 0.15, 0x2E5E1E, -0.08, baseY + h * 0.35, 0);
      const budY = baseY + h * 0.65;
      const bs = 0.15 + progress * 0.2;
      box(bs, bs * 1.2, bs, plantColor, 0, budY, 0); // inner bud
      if (progress > 0.6) {
        box(bs * 1.4, bs * 0.5, bs * 0.4, plantColor, 0, budY - bs * 0.2, 0); // outer petals
        box(bs * 0.4, bs * 0.5, bs * 1.4, plantColor, 0, budY - bs * 0.2, 0);
      }
      break;
    }

    case 'tulip': {
      // Curved stem + cup-shaped bloom
      box(0.08, h * 0.7, 0.08, stemColor, 0, baseY + h * 0.35, 0);
      if (progress > 0.3) box(0.3, 0.05, 0.12, leafColor, 0, baseY + h * 0.15, 0.08);
      const ty = baseY + h * 0.7;
      const ts = 0.12 + progress * 0.18;
      box(ts, ts * 1.5, ts, plantColor, 0, ty, 0); // center petal
      box(ts * 0.7, ts * 1.2, ts * 0.5, topColor, ts * 0.4, ty - 0.02, 0); // side
      box(ts * 0.7, ts * 1.2, ts * 0.5, topColor, -ts * 0.4, ty - 0.02, 0);
      break;
    }

    case 'orchid': {
      // Tall thin stem + exotic layered flower
      box(0.06, h * 0.8, 0.06, stemColor, 0, baseY + h * 0.4, 0);
      if (progress > 0.4) box(0.4, 0.04, 0.15, leafColor, 0, baseY + 0.1, 0);
      const oy = baseY + h * 0.8;
      const os = 0.1 + progress * 0.2;
      box(os * 2.5, 0.06, os, plantColor, 0, oy, 0);
      box(os, 0.06, os * 2.5, topColor, 0, oy, 0);
      box(os * 0.5, 0.15, os * 0.5, 0xFFFFFF, 0, oy + 0.06, 0); // center
      break;
    }

    // â”€â”€â”€ VEGETABLES â”€â”€â”€
    case 'carrot': {
      // Green leafy top, orange root peeking from soil
      const leafH = h * 0.6;
      box(0.3, leafH, 0.08, leafColor, 0, baseY + leafH / 2, 0);
      box(0.08, leafH, 0.3, leafColor, 0, baseY + leafH / 2, 0);
      box(0.2, leafH * 0.8, 0.2, 0x2E7D32, 0, baseY + leafH * 0.4, 0);
      if (progress > 0.5) box(0.15, 0.2, 0.15, plantColor, 0, baseY - 0.05, 0); // orange root showing
      break;
    }

    case 'tomato': {
      // Bush with round red fruits
      box(0.12, h * 0.5, 0.12, stemColor, 0, baseY + h * 0.25, 0);
      const bushY = baseY + h * 0.5;
      box(0.5, 0.3, 0.5, leafColor, 0, bushY, 0); // bush
      if (progress > 0.5) {
        const ts = 0.12 + progress * 0.08;
        box(ts, ts, ts, plantColor, 0.15, bushY + 0.1, 0.1);
        box(ts, ts, ts, plantColor, -0.1, bushY + 0.05, -0.12);
        if (progress > 0.75) box(ts, ts, ts, plantColor, 0, bushY + 0.15, 0);
      }
      break;
    }

    case 'pumpkin': {
      // Low vine + big round pumpkin on ground
      box(0.08, 0.04, 0.5, stemColor, 0, baseY + 0.02, 0); // vine
      if (progress > 0.3) {
        box(0.2, 0.04, 0.12, leafColor, -0.15, baseY + 0.05, 0.15);
        box(0.2, 0.04, 0.12, leafColor, 0.15, baseY + 0.05, -0.15);
      }
      const ps = 0.2 + progress * 0.4;
      box(ps, ps * 0.7, ps, plantColor, 0, baseY + ps * 0.35, 0);
      if (progress > 0.6) box(0.06, 0.12, 0.06, stemColor, 0, baseY + ps * 0.7 + 0.06, 0); // stem on top
      break;
    }

    case 'strawberry': {
      // Low bush + small red berries
      box(0.1, h * 0.3, 0.1, stemColor, 0, baseY + h * 0.15, 0);
      box(0.4, 0.15, 0.4, leafColor, 0, baseY + h * 0.35, 0);
      if (progress > 0.5) {
        box(0.1, 0.12, 0.1, plantColor, 0.12, baseY + 0.1, 0.12);
        box(0.1, 0.12, 0.1, plantColor, -0.1, baseY + 0.08, -0.1);
        if (isReady) box(0.1, 0.12, 0.1, plantColor, 0, baseY + 0.12, 0);
      }
      break;
    }

    case 'blueberry': {
      // Small bush + clusters of blue
      box(0.12, h * 0.4, 0.12, stemColor, 0, baseY + h * 0.2, 0);
      box(0.35, 0.25, 0.35, leafColor, 0, baseY + h * 0.45, 0);
      if (progress > 0.5) {
        const bs = 0.07;
        box(bs, bs, bs, plantColor, 0.12, baseY + h * 0.5, 0.08);
        box(bs, bs, bs, plantColor, -0.08, baseY + h * 0.45, -0.1);
        box(bs, bs, bs, plantColor, 0.05, baseY + h * 0.55, -0.05);
        if (isReady) box(bs, bs, bs, plantColor, -0.1, baseY + h * 0.52, 0.06);
      }
      break;
    }

    // â”€â”€â”€ CACTUS â”€â”€â”€
    case 'cactus': {
      // Classic cactus shape with arms
      const cw = 0.2 + progress * 0.1;
      box(cw, h * 0.8, cw, plantColor, 0, baseY + h * 0.4, 0); // main body
      if (progress > 0.4) box(cw * 0.7, h * 0.3, cw * 0.7, topColor, cw * 0.7, baseY + h * 0.5, 0); // right arm
      if (progress > 0.6) box(cw * 0.7, h * 0.25, cw * 0.7, topColor, -cw * 0.7, baseY + h * 0.6, 0); // left arm
      if (isReady) box(0.1, 0.1, 0.1, 0xFF69B4, 0, baseY + h * 0.85, 0); // pink flower on top
      break;
    }

    // â”€â”€â”€ MUSHROOM â”€â”€â”€
    case 'mushroom': {
      // Short thick stem + wide flat cap
      const mw = 0.12 + progress * 0.08;
      box(mw, h * 0.4, mw, 0xF5F5DC, 0, baseY + h * 0.2, 0); // white stem
      const capW = 0.25 + progress * 0.3;
      box(capW, h * 0.2, capW, plantColor, 0, baseY + h * 0.45, 0); // brown cap
      if (progress > 0.5) { // spots on cap
        box(0.06, 0.04, 0.06, topColor, 0.08, baseY + h * 0.5, 0.05);
        box(0.06, 0.04, 0.06, topColor, -0.06, baseY + h * 0.5, -0.07);
      }
      break;
    }

    // â”€â”€â”€ HERBS â”€â”€â”€
    // (lavender handled above with daisy)

    // â”€â”€â”€ TREES (date_palm, fig, olive, charoset) â”€â”€â”€
    case 'date_palm': {
      // Tall trunk + fan leaves at top
      box(0.15, h * 0.85, 0.15, seed.color, 0, baseY + h * 0.42, 0);
      if (progress > 0.3) {
        const ly = baseY + h * 0.85;
        box(0.6, 0.05, 0.12, topColor, 0, ly, 0);
        box(0.12, 0.05, 0.6, topColor, 0, ly, 0);
        box(0.4, 0.05, 0.4, topColor, 0, ly - 0.04, 0);
      }
      if (isReady) { // dates hanging
        box(0.06, 0.1, 0.06, 0x8B4513, 0.15, baseY + h * 0.75, 0);
        box(0.06, 0.1, 0.06, 0x8B4513, -0.12, baseY + h * 0.72, 0.1);
      }
      break;
    }

    case 'fig':
    case 'olive':
    case 'charoset': {
      // Round bushy tree
      box(0.15, h * 0.5, 0.15, 0x6D4C41, 0, baseY + h * 0.25, 0); // trunk
      const canopyS = 0.3 + progress * 0.3;
      box(canopyS, canopyS, canopyS, topColor, 0, baseY + h * 0.6, 0);
      if (progress > 0.5) box(canopyS * 0.8, canopyS * 0.7, canopyS * 0.8, leafColor, 0, baseY + h * 0.7, 0);
      if (isReady) {
        const fc = seedId === 'olive' ? 0x556B2F : seedId === 'fig' ? 0x4B0082 : 0x8B4513;
        box(0.08, 0.08, 0.08, fc, 0.12, baseY + h * 0.55, 0.1);
        box(0.08, 0.08, 0.08, fc, -0.1, baseY + h * 0.5, -0.08);
      }
      break;
    }

    case 'wheat': {
      // Multiple thin stalks
      for (let s = -1; s <= 1; s++) {
        box(0.05, h * 0.7, 0.05, stemColor, s * 0.1, baseY + h * 0.35, 0);
        if (progress > 0.4) box(0.08, h * 0.2, 0.08, plantColor, s * 0.1, baseY + h * 0.75, 0); // grain head
      }
      if (progress > 0.3) {
        box(0.05, h * 0.6, 0.05, stemColor, 0.05, baseY + h * 0.3, 0.08);
        if (progress > 0.5) box(0.08, h * 0.2, 0.08, plantColor, 0.05, baseY + h * 0.65, 0.08);
      }
      break;
    }

    // â”€â”€â”€ PURIM SPECIALS â”€â”€â”€
    case 'hamentash': {
      // Triangular shape (3 blocks arranged as triangle)
      const ts = 0.15 + progress * 0.2;
      box(0.08, h * 0.3, 0.08, stemColor, 0, baseY + h * 0.15, 0);
      box(ts * 2, ts * 0.4, ts, plantColor, 0, baseY + h * 0.4, 0); // base
      box(ts * 1.2, ts * 0.4, ts * 0.8, plantColor, 0, baseY + h * 0.55, 0); // middle
      box(ts * 0.5, ts * 0.3, ts * 0.5, topColor, 0, baseY + h * 0.65, 0); // top (filling)
      break;
    }

    case 'gragger': {
      // Stick with noisemaker on top
      box(0.08, h * 0.6, 0.08, 0x8B4513, 0, baseY + h * 0.3, 0); // handle
      const gs = 0.15 + progress * 0.2;
      box(gs, gs * 1.5, gs * 0.5, plantColor, 0, baseY + h * 0.7, 0); // gragger head
      if (isReady) box(gs * 0.3, gs * 0.3, gs * 0.8, topColor, 0, baseY + h * 0.7, 0); // spinner
      break;
    }

    case 'megillah': {
      // Scroll shape â€” two pillars with sheet between
      const ms = 0.1 + progress * 0.1;
      box(ms, h * 0.7, ms, 0x8B4513, -0.15, baseY + h * 0.35, 0); // left roller
      box(ms, h * 0.7, ms, 0x8B4513, 0.15, baseY + h * 0.35, 0); // right roller
      box(0.25, h * 0.6, 0.04, plantColor, 0, baseY + h * 0.32, 0); // parchment
      if (isReady) box(0.04, h * 0.5, 0.02, 0x333333, 0, baseY + h * 0.3, 0.03); // text lines
      break;
    }

    case 'mishloach': {
      // Gift basket
      box(0.35, 0.15, 0.25, 0x8B6914, 0, baseY + 0.1, 0); // basket base
      box(0.38, 0.04, 0.04, 0x8B6914, 0, baseY + 0.3, 0); // handle
      if (progress > 0.3) box(0.1, 0.12, 0.1, plantColor, -0.08, baseY + 0.22, 0);
      if (progress > 0.5) box(0.1, 0.1, 0.1, topColor, 0.08, baseY + 0.2, 0.04);
      if (isReady) box(0.08, 0.08, 0.08, 0xFF69B4, 0, baseY + 0.25, -0.04);
      break;
    }

    case 'crown': {
      // Crown shape â€” base + points
      box(0.1, h * 0.4, 0.1, 0x8B4513, 0, baseY + h * 0.2, 0); // cushion/stand
      const cs = 0.15 + progress * 0.15;
      box(cs * 2.5, cs * 0.5, cs * 2, plantColor, 0, baseY + h * 0.5, 0); // crown band
      if (progress > 0.4) { // crown points
        box(cs * 0.4, cs * 0.6, cs * 0.4, plantColor, -cs, baseY + h * 0.65, 0);
        box(cs * 0.4, cs * 0.8, cs * 0.4, plantColor, 0, baseY + h * 0.7, 0);
        box(cs * 0.4, cs * 0.6, cs * 0.4, plantColor, cs, baseY + h * 0.65, 0);
      }
      if (isReady) box(0.08, 0.08, 0.08, 0xFF0000, 0, baseY + h * 0.75, 0); // jewel
      break;
    }

    case 'mask': {
      // Mask on a stick
      box(0.06, h * 0.5, 0.06, 0x8B4513, 0.12, baseY + h * 0.25, 0); // stick
      const mks = 0.15 + progress * 0.15;
      box(mks * 2.5, mks * 1.5, 0.08, plantColor, 0, baseY + h * 0.6, 0); // mask face
      if (progress > 0.4) { // eye holes
        box(0.06, 0.06, 0.06, 0x000000, -mks * 0.5, baseY + h * 0.62, 0.03);
        box(0.06, 0.06, 0.06, 0x000000, mks * 0.5, baseY + h * 0.62, 0.03);
      }
      if (isReady) box(mks * 1.5, 0.04, 0.06, topColor, 0, baseY + h * 0.72, 0); // feather
      break;
    }

    // â”€â”€â”€ PESACH â”€â”€â”€
    case 'matza': {
      // Flat squares stacked
      const mzs = 0.2 + progress * 0.2;
      box(mzs, 0.05, mzs, plantColor, 0, baseY + 0.05, 0);
      if (progress > 0.3) box(mzs * 0.95, 0.05, mzs * 0.95, topColor, 0.02, baseY + 0.1, -0.02);
      if (progress > 0.6) box(mzs * 0.9, 0.05, mzs * 0.9, plantColor, -0.01, baseY + 0.15, 0.01);
      break;
    }

    case 'maror': {
      // Bitter herb bush â€” spiky leaves
      for (let a = 0; a < 5; a++) {
        const angle = (a / 5) * Math.PI * 2;
        const lx = Math.cos(angle) * 0.12;
        const lz = Math.sin(angle) * 0.12;
        box(0.08, h * 0.5 + a * 0.03, 0.04, plantColor, lx, baseY + h * 0.25, lz);
      }
      if (isReady) box(0.15, 0.08, 0.15, topColor, 0, baseY + h * 0.55, 0);
      break;
    }

    case 'wine': {
      // Grape vine on trellis
      box(0.08, h * 0.7, 0.08, stemColor, 0, baseY + h * 0.35, 0);
      if (progress > 0.3) box(0.5, 0.05, 0.08, stemColor, 0, baseY + h * 0.7, 0); // crossbar
      if (progress > 0.5) { // grape clusters
        const gs = 0.06 + progress * 0.04;
        box(gs, gs, gs, plantColor, -0.12, baseY + h * 0.55, 0);
        box(gs, gs, gs, plantColor, -0.12, baseY + h * 0.48, 0.05);
        box(gs, gs, gs, plantColor, 0.12, baseY + h * 0.52, 0);
        if (isReady) box(gs, gs, gs, plantColor, 0.12, baseY + h * 0.45, -0.04);
      }
      break;
    }

    // â”€â”€â”€ CHANUKAH â”€â”€â”€
    case 'sufganiya': {
      // Round donut shape
      const ds = 0.15 + progress * 0.2;
      box(ds * 2, ds, ds * 2, plantColor, 0, baseY + ds * 0.5, 0); // donut body
      if (progress > 0.5) box(ds * 1.5, 0.04, ds * 1.5, 0xFFF0E0, 0, baseY + ds + 0.01, 0); // sugar top
      if (isReady) box(0.06, 0.08, 0.06, topColor, 0, baseY + ds + 0.04, 0); // jelly dot
      break;
    }

    case 'menorah': {
      // Menorah shape â€” base + 9 branches
      box(0.3, 0.06, 0.12, plantColor, 0, baseY + 0.05, 0); // base
      box(0.06, h * 0.6, 0.06, plantColor, 0, baseY + h * 0.3, 0); // center
      if (progress > 0.3) {
        for (let b = -3; b <= 3; b++) {
          if (b === 0) continue;
          const bx = b * 0.06;
          box(0.04, h * 0.45, 0.04, plantColor, bx, baseY + h * 0.25, 0);
        }
      }
      if (isReady) { // flames
        for (let b = -3; b <= 3; b++) {
          box(0.03, 0.06, 0.03, topColor, b === 0 ? 0 : b * 0.06, baseY + h * 0.6, 0);
        }
        box(0.04, 0.08, 0.04, topColor, 0, baseY + h * 0.65, 0); // shamash taller
      }
      break;
    }

    // â”€â”€â”€ ROSH HASHANA â”€â”€â”€
    case 'apple_honey': {
      // Apple + honey jar
      const as = 0.12 + progress * 0.15;
      box(as, as, as, 0xFF4444, -0.1, baseY + as * 0.5, 0); // apple
      if (progress > 0.3) box(0.03, 0.08, 0.03, stemColor, -0.1, baseY + as + 0.04, 0); // apple stem
      if (progress > 0.5) {
        box(as * 0.8, as * 1.2, as * 0.8, topColor, 0.12, baseY + as * 0.6, 0); // honey jar
        if (isReady) box(as * 0.5, 0.04, as * 0.5, 0xFFD700, 0.12, baseY + as * 1.2 + 0.02, 0); // honey drip
      }
      break;
    }

    case 'pomegranate': {
      // Round fruit with crown top
      box(0.08, h * 0.3, 0.08, stemColor, 0, baseY + h * 0.15, 0);
      const ps = 0.15 + progress * 0.2;
      box(ps, ps * 1.2, ps, plantColor, 0, baseY + h * 0.45, 0);
      if (isReady) {
        box(ps * 0.3, 0.1, ps * 0.3, 0x8B0000, 0, baseY + h * 0.65, 0); // crown
        box(ps * 0.5, 0.04, ps * 0.5, topColor, 0, baseY + h * 0.68, 0);
      }
      break;
    }

    case 'shofar': {
      // Curved horn shape (approximated with angled blocks)
      box(0.12, h * 0.15, 0.12, plantColor, 0, baseY + 0.1, 0); // wide end
      box(0.1, h * 0.5, 0.1, plantColor, 0.08, baseY + h * 0.35, 0); // body
      if (progress > 0.4) box(0.07, h * 0.25, 0.07, topColor, 0.18, baseY + h * 0.6, 0); // mouthpiece
      break;
    }

    // â”€â”€â”€ LAG B'OMER â”€â”€â”€
    case 'bonfire': {
      // Stacked logs + fire
      box(0.3, 0.08, 0.08, 0x8B4513, 0, baseY + 0.06, -0.05);
      box(0.08, 0.08, 0.3, 0x8B4513, 0, baseY + 0.06, 0);
      box(0.25, 0.08, 0.08, 0x6D4C41, 0, baseY + 0.14, 0.03);
      if (progress > 0.3) {
        box(0.12, h * 0.4, 0.12, plantColor, 0, baseY + h * 0.3, 0); // fire core
        box(0.08, h * 0.3, 0.08, topColor, 0.06, baseY + h * 0.25, 0.04);
        if (isReady) box(0.06, h * 0.2, 0.06, 0xFFFF00, 0, baseY + h * 0.5, 0); // tip
      }
      break;
    }

    case 'bow': {
      // Bow + arrow shape
      box(0.04, h * 0.7, 0.04, plantColor, 0, baseY + h * 0.35, 0); // bow vertical
      if (progress > 0.3) {
        box(0.04, 0.04, 0.06, 0xDEB887, 0, baseY + h * 0.7, 0); // bow tip
        box(0.04, 0.04, 0.06, 0xDEB887, 0, baseY + h * 0.05, 0); // bow bottom
        box(0.02, h * 0.65, 0.02, 0xCCCCCC, 0.02, baseY + h * 0.35, 0); // string
      }
      if (progress > 0.6) box(0.03, 0.03, 0.4, topColor, 0, baseY + h * 0.4, 0); // arrow
      break;
    }

    // â”€â”€â”€ SHAVUOT â”€â”€â”€
    case 'cheesecake': {
      const cs = 0.15 + progress * 0.2;
      box(cs * 2, cs * 0.4, cs * 2, plantColor, 0, baseY + cs * 0.2, 0); // cake body
      if (progress > 0.4) box(cs * 2.1, 0.04, cs * 2.1, 0xFFE4B5, 0, baseY + cs * 0.42, 0); // crust top
      if (isReady) box(0.1, 0.1, 0.1, 0xFF6347, 0, baseY + cs * 0.5, 0); // strawberry on top
      break;
    }

    case 'milk_honey': {
      // Milk jug + honey pot
      box(0.12, h * 0.4, 0.12, 0xFFFFF0, -0.1, baseY + h * 0.2, 0); // milk
      if (progress > 0.3) box(0.04, 0.1, 0.04, 0xFFFFF0, -0.1, baseY + h * 0.42, 0); // spout
      if (progress > 0.5) box(0.1, h * 0.35, 0.1, topColor, 0.1, baseY + h * 0.18, 0); // honey
      if (isReady) box(0.15, 0.03, 0.03, 0xFFD700, 0.1, baseY + h * 0.35, 0.06); // drip
      break;
    }

    // â”€â”€â”€ FALLBACK (generic plant for any new/unknown seeds) â”€â”€â”€
    default: {
      box(0.12, h * 0.7, 0.12, stemColor, 0, baseY + h * 0.35, 0);
      const tw = 0.2 + progress * 0.25;
      box(tw, tw * 0.8, tw, plantColor, 0, baseY + h * 0.75, 0);
      if (progress > 0.3) {
        box(0.25, 0.06, 0.1, leafColor, 0.15, baseY + h * 0.3, 0);
        box(0.25, 0.06, 0.1, leafColor, -0.15, baseY + h * 0.4, 0);
      }
      break;
    }
  }

  return g;
}

// â”€â”€â”€ Plant Visuals â”€â”€â”€
function updatePlantMeshes() {
  for (let i = 0; i < plotMeshes.length; i++) {
    const pm = plotMeshes[i];
    const plotData = gameState.plots[i];

    // Remove old plant
    if (pm.plantMesh) {
      pm.group.remove(pm.plantMesh);
      pm.plantMesh = null;
    }
    if (pm.glowMesh) {
      pm.group.remove(pm.glowMesh);
      pm.glowMesh = null;
    }

    if (!plotData) {
      // Reset soil color for empty
      pm.soilMesh.material = new THREE.MeshLambertMaterial({ color: 0x5D4037 });
      continue;
    }

    const seed = getSeedData(plotData.seedId);
    if (!seed) continue;

    const progress = getEffectiveProgress(plotData);
    const isReady = progress >= 1;

    const plantGroup = buildPlantModel(plotData.seedId, seed, progress, isReady);

    // Ready indicator: gentle bob and glow
    const waterLevel = plotData.waterLevel != null ? plotData.waterLevel : 100;
    const isDry = waterLevel <= 0;
    const rarity = seed.rarity || 'common';

    if (isReady) {
      // Glow color by rarity
      const glowColor = rarity === 'legendary' ? 0xFFD700 : rarity === 'rare' ? 0xA855F7 : rarity === 'uncommon' ? 0x3B82F6 : 0x7CFC00;
      const glowGeo = new THREE.BoxGeometry(PLOT_SIZE - 0.15, 0.06, PLOT_SIZE - 0.15);
      const glowMat = new THREE.MeshBasicMaterial({ color: glowColor, transparent: true, opacity: 0.35 });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.y = 0.32;
      pm.group.add(glow);
      pm.glowMesh = glow;
      pm.soilMesh.material = new THREE.MeshLambertMaterial({ color: 0x7B5B3A });
    } else if (isDry) {
      // Dry / thirsty â€” pale cracked soil color
      pm.soilMesh.material = new THREE.MeshLambertMaterial({ color: 0x9E9070 });
    } else {
      pm.soilMesh.material = new THREE.MeshLambertMaterial({ color: 0x5D4037 });
    }

    pm.group.add(plantGroup);
    pm.plantMesh = plantGroup;
  }
}

function lerpColor(a, b, t) {
  const ar = (a >> 16) & 0xff, ag = (a >> 8) & 0xff, ab = a & 0xff;
  const br = (b >> 16) & 0xff, bg = (b >> 8) & 0xff, bb = b & 0xff;
  const r = Math.round(ar + (br - ar) * t);
  const g = Math.round(ag + (bg - ag) * t);
  const bl = Math.round(ab + (bb - ab) * t);
  return (r << 16) | (g << 8) | bl;
}

// â”€â”€â”€ Player Controls â”€â”€â”€
function initControls() {
  // Prevent default touch behaviors on the canvas (pull-to-refresh, pinch zoom)
  renderer.domElement.addEventListener('touchstart', (e) => { if (started) e.preventDefault(); }, {passive: false});
  renderer.domElement.addEventListener('touchmove', (e) => { if (started) e.preventDefault(); }, {passive: false});
  document.body.addEventListener('gesturestart', (e) => e.preventDefault(), {passive: false});
  document.body.addEventListener('gesturechange', (e) => e.preventDefault(), {passive: false});

  // Third-person camera: right-click drag to orbit
  let isOrbiting = false;
  renderer.domElement.addEventListener('mousedown', (e) => {
    if (!started) return;
    if (e.button === 2 || e.button === 0) isOrbiting = true;
  });
  document.addEventListener('mouseup', () => { isOrbiting = false; });
  renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

  document.addEventListener('pointerlockchange', () => {
    isPointerLocked = document.pointerLockElement === renderer.domElement;
  });

  document.addEventListener('mousemove', (e) => {
    if (!started || !isOrbiting) return;
    yaw -= e.movementX * 0.004;
    pitch -= e.movementY * 0.004;
    pitch = clamp(pitch, -0.6, 0.8);
  });

  document.addEventListener('keydown', (e) => {
    if (!started) return;
    switch(e.code) {
      case 'KeyW': case 'ArrowUp': moveForward = true; break;
      case 'KeyS': case 'ArrowDown': moveBackward = true; break;
      case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
      case 'KeyD': case 'ArrowRight': moveRight = true; break;
      case 'Space':
        e.preventDefault();
        if (playerOnGround) { playerVelocity.y = JUMP_FORCE; playerOnGround = false; }
        break;
      case 'KeyE': tryInteract(); break;
      case 'KeyQ':
        e.preventDefault();
        if (interactTarget !== null) waterPlot(interactTarget);
        break;
      case 'KeyI':
        e.preventDefault();
        toggleInventory();
        break;
      case 'KeyB':
        e.preventDefault();
        toggleShop();
        break;
      case 'KeyJ':
        e.preventDefault();
        openAchievements();
        break;
      case 'Digit1': case 'Digit2': case 'Digit3': case 'Digit4':
      case 'Digit5': case 'Digit6': case 'Digit7': case 'Digit8': case 'Digit9':
        selectHotbarSlot(parseInt(e.code.replace('Digit', '')) - 1);
        break;
      case 'Escape':
        closeAllPanels();
        break;
    }
  });

  document.addEventListener('keyup', (e) => {
    switch(e.code) {
      case 'KeyW': case 'ArrowUp': moveForward = false; break;
      case 'KeyS': case 'ArrowDown': moveBackward = false; break;
      case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
      case 'KeyD': case 'ArrowRight': moveRight = false; break;
    }
  });

  // Click to interact
  renderer.domElement.addEventListener('mousedown', (e) => {
    if (!isPointerLocked || !started) return;
    if (e.button === 0) tryInteract();
  });

  // Mobile controls
  initTouchControls();
}

// â”€â”€â”€ Touch Controls â”€â”€â”€
function initTouchControls() {
  isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

  // Force-show touch controls on mobile (CSS media query fallback)
  if (isMobile) {
    document.getElementById('touch-controls').style.display = 'block';
  }

  const touchMove = $('#touch-move');
  const touchStick = $('#touch-move-stick');
  const touchLook = $('#touch-look');
  const touchJump = $('#touch-jump');
  const touchInteract = $('#touch-interact');
  const touchInv = $('#touch-inv');
  const touchShop = $('#touch-shop');

  let moveTouch = null;
  let lookTouch = null;
  let lastLookX = 0, lastLookY = 0;

  touchMove.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
      moveTouch = e.touches[0].identifier;
    }
  }, {passive: false});

  touchMove.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier === moveTouch) {
        const rect = touchMove.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dx = (t.clientX - cx) / (rect.width / 2);
        const dy = (t.clientY - cy) / (rect.height / 2);
        const len = Math.sqrt(dx*dx + dy*dy);
        const maxLen = 1;
        if (len > maxLen) {
          touchMoveVec.x = (dx / len) * maxLen;
          touchMoveVec.y = (dy / len) * maxLen;
        } else {
          touchMoveVec.x = dx;
          touchMoveVec.y = dy;
        }
        touchStick.style.transform = `translate(calc(-50% + ${touchMoveVec.x * 30}px), calc(-50% + ${touchMoveVec.y * 30}px))`;
      }
    }
  }, {passive: false});

  const resetMove = (e) => {
    for (const t of e.changedTouches) {
      if (t.identifier === moveTouch) {
        moveTouch = null;
        touchMoveVec.x = 0;
        touchMoveVec.y = 0;
        touchStick.style.transform = 'translate(-50%, -50%)';
      }
    }
  };
  touchMove.addEventListener('touchend', resetMove, {passive: false});
  touchMove.addEventListener('touchcancel', resetMove, {passive: false});

  // Look
  touchLook.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (e.touches.length > 0) {
      const t = e.touches[e.touches.length - 1];
      lookTouch = t.identifier;
      lastLookX = t.clientX;
      lastLookY = t.clientY;
    }
  }, {passive: false});

  touchLook.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier === lookTouch) {
        const dx = t.clientX - lastLookX;
        const dy = t.clientY - lastLookY;
        yaw -= dx * 0.004;
        pitch -= dy * 0.004;
        pitch = clamp(pitch, -0.6, 0.8);
        lastLookX = t.clientX;
        lastLookY = t.clientY;
      }
    }
  }, {passive: false});

  const resetLook = (e) => {
    for (const t of e.changedTouches) {
      if (t.identifier === lookTouch) { lookTouch = null; }
    }
  };
  touchLook.addEventListener('touchend', resetLook, {passive: false});
  touchLook.addEventListener('touchcancel', resetLook, {passive: false});

  touchJump.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (playerOnGround) { playerVelocity.y = JUMP_FORCE; playerOnGround = false; }
  }, {passive: false});

  touchInteract.addEventListener('touchstart', (e) => {
    e.preventDefault();
    tryInteract();
  }, {passive: false});

  touchInv.addEventListener('touchstart', (e) => {
    e.preventDefault();
    toggleInventory();
  }, {passive: false});

  touchShop.addEventListener('touchstart', (e) => {
    e.preventDefault();
    toggleShop();
  }, {passive: false});
}

// â”€â”€â”€ Player position (separate from camera) â”€â”€â”€
let playerPos = new THREE.Vector3(0, 0, 0);
let playerGroundY = 0;
let walkCycle = 0;
let isMoving = false;

// â”€â”€â”€ Player Update (third-person) â”€â”€â”€
function updatePlayer(dt) {
  // Direction from yaw (camera orbit angle)
  const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
  const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));

  const moveDir = new THREE.Vector3();

  // Keyboard
  if (moveForward) moveDir.add(forward);
  if (moveBackward) moveDir.sub(forward);
  if (moveLeft) moveDir.sub(right);
  if (moveRight) moveDir.add(right);

  // Touch
  if (touchMoveVec.x !== 0 || touchMoveVec.y !== 0) {
    moveDir.add(right.clone().multiplyScalar(touchMoveVec.x));
    moveDir.add(forward.clone().multiplyScalar(-touchMoveVec.y));
  }

  isMoving = moveDir.length() > 0;
  if (isMoving) moveDir.normalize();

  // Apply movement to player position
  playerPos.x += moveDir.x * PLAYER_SPEED * dt;
  playerPos.z += moveDir.z * PLAYER_SPEED * dt;

  // Gravity
  playerVelocity.y -= GRAVITY * dt;
  playerGroundY += playerVelocity.y * dt;

  if (playerGroundY <= 0) {
    playerGroundY = 0;
    playerVelocity.y = 0;
    playerOnGround = true;
  }

  // World bounds
  const bound = WORLD_SIZE / 2 - 1;
  playerPos.x = clamp(playerPos.x, -bound, bound);
  playerPos.z = clamp(playerPos.z, -bound, bound);

  // Update player model
  if (playerModel) {
    playerModel.position.set(playerPos.x, playerGroundY, playerPos.z);

    // Face movement direction (or face camera forward direction)
    if (isMoving) {
      playerModel.rotation.y = Math.atan2(moveDir.x, moveDir.z);
    }

    // Walk animation â€” swing arms and legs
    if (isMoving) {
      walkCycle += dt * 10;
      const swing = Math.sin(walkCycle) * 0.4;
      const parts = playerModel.userData;
      if (parts.armL) parts.armL.rotation.x = swing;
      if (parts.armR) parts.armR.rotation.x = -swing;
      if (parts.legL) parts.legL.rotation.x = -swing;
      if (parts.legR) parts.legR.rotation.x = swing;
    } else {
      walkCycle = 0;
      const parts = playerModel.userData;
      if (parts.armL) parts.armL.rotation.x = 0;
      if (parts.armR) parts.armR.rotation.x = 0;
      if (parts.legL) parts.legL.rotation.x = 0;
      if (parts.legR) parts.legR.rotation.x = 0;
    }
  }

  // Third-person camera: orbit behind the player
  const camX = playerPos.x + Math.sin(yaw) * CAM_DISTANCE;
  const camZ = playerPos.z + Math.cos(yaw) * CAM_DISTANCE;
  const camY = playerGroundY + PLAYER_HEIGHT + CAM_HEIGHT_OFFSET + Math.sin(pitch) * CAM_DISTANCE * 0.5;

  camera.position.set(camX, clamp(camY, 1.5, 20), camZ);
  camera.lookAt(playerPos.x, playerGroundY + PLAYER_HEIGHT, playerPos.z);
}

// â”€â”€â”€ Proximity / Interaction â”€â”€â”€
function updateInteraction() {
  interactTarget = null;

  // Find closest plot by distance (proximity-based, no aiming needed)
  let closestDist = Infinity;
  let closestIdx = -1;

  for (let i = 0; i < plotMeshes.length; i++) {
    const pos = getPlotWorldPos(i);
    const dx = playerPos.x - pos.x;
    const dz = playerPos.z - pos.z;
    const dist = Math.sqrt(dx * dx + dz * dz);
    if (dist < closestDist) {
      closestDist = dist;
      closestIdx = i;
    }
  }

  if (closestIdx >= 0 && closestDist <= INTERACT_DIST) {
    interactTarget = closestIdx;
    const plotData = gameState.plots[closestIdx];

    if (!plotData) {
      showPrompt('Press <b>E</b> to Plant');
      showPlotLabel('Empty Plot');
    } else {
      const seed = getSeedData(plotData.seedId);
      const progress = getEffectiveProgress(plotData);
      const isReady = progress >= 1;

      const waterPct = Math.round(plotData.waterLevel || 0);
      const waterIcon = waterPct > 60 ? 'ðŸ’§' : waterPct > 20 ? 'ðŸ’¦' : 'ðŸœï¸';

      if (isReady) {
        showPrompt(`Press <b>E</b> to Harvest ${seed.emoji} ${seed.name}`);
        showPlotLabel(`${seed.emoji} ${seed.name} â€” READY! ${waterIcon}${waterPct}%`);
      } else {
        const stage = progress < 0.33 ? 'ðŸŒ± Sprout' : progress < 0.66 ? 'ðŸŒ¿ Growing' : 'ðŸŒ» Almost Ready';
        const remaining = Math.ceil(plotData.growTime - elapsed);
        const paused = waterPct <= 0 ? ' âš ï¸ THIRSTY!' : '';
        showPrompt(`Press <b>Q</b> to Water | <b>E</b> to Interact`);
        showPlotLabel(`${seed.emoji} ${stage} â€” ${remaining}s ${waterIcon}${waterPct}%${paused}`);
      }
    }
  } else {
    // Check if near Shlomo the shopkeeper
    const dxShop = playerPos.x - SHOPKEEPER_POS.x;
    const dzShop = playerPos.z - SHOPKEEPER_POS.z;
    const distToShop = Math.sqrt(dxShop * dxShop + dzShop * dzShop);

    // Check if near well
    const dxWell = playerPos.x - WELL_POS.x;
    const dzWell = playerPos.z - WELL_POS.z;
    const distToWell = Math.sqrt(dxWell * dxWell + dzWell * dzWell);

    // Check if near dog
    const dxDog = playerPos.x - dogPos.x;
    const dzDog = playerPos.z - dogPos.z;
    const distToDog = Math.sqrt(dxDog * dxDog + dzDog * dzDog);

    if (distToShop <= SHOPKEEPER_INTERACT_DIST) {
      nearShopkeeper = true;
      nearWell = false;
      nearDog = false;
      const holidays = getActiveHolidayLabels();
      const seasonalMsg = holidays.length > 0 ? ` â€” ${holidays.join(' ')} specials!` : '';
      showPrompt(`Press <b>E</b> to talk to <b>Shlomo</b> ðŸŒ±${seasonalMsg}`);
      showPlotLabel("Shlomo's Seeds");
    } else if (distToWell <= WELL_INTERACT_DIST) {
      nearWell = true;
      nearShopkeeper = false;
      nearDog = false;
      showPrompt(`Press <b>E</b> to refill watering can ðŸš°`);
      showPlotLabel(`ðŸ’§ Water Can: ${Math.round(gameState.waterCan)}%`);
    } else if (distToDog <= DOG_INTERACT_DIST) {
      nearDog = true;
      nearShopkeeper = false;
      nearWell = false;
      showPrompt(`Press <b>E</b> to pet <b>Buddy</b> ðŸ•`);
      showPlotLabel('ðŸ• Buddy');
    } else {
      nearShopkeeper = false;
      nearWell = false;
      nearDog = false;
      hidePrompt();
      hidePlotLabel();
    }
  }
}

function showPrompt(html) {
  interactPromptEl.innerHTML = html;
  interactPromptEl.classList.add('visible');
}
function hidePrompt() { interactPromptEl.classList.remove('visible'); }
function showPlotLabel(text) {
  plotLabelEl.textContent = text;
  plotLabelEl.classList.add('visible');
}
function hidePlotLabel() { plotLabelEl.classList.remove('visible'); }

// â”€â”€â”€ Interact Action â”€â”€â”€
function tryInteract() {
  if (isAnyPanelOpen()) return;

  // Shlomo interaction
  if (nearShopkeeper && interactTarget === null) {
    openShop();
    return;
  }

  // Well interaction
  if (nearWell && interactTarget === null) {
    refillWaterCan();
    return;
  }

  // Dog interaction
  if (nearDog && interactTarget === null) {
    petDog();
    return;
  }

  if (interactTarget === null) return;

  const plotData = gameState.plots[interactTarget];

  if (!plotData) {
    // Open seed selector
    openSeedPanel(interactTarget);
  } else {
    // Check if harvestable
    const effectiveProg = getEffectiveProgress(plotData);
    if (effectiveProg >= 1) {
      harvestPlot(interactTarget);
    }
  }
}

// â”€â”€â”€ Planting â”€â”€â”€
function openSeedPanel(plotIndex) {
  if (document.pointerLockElement) document.exitPointerLock();

  const panel = $('#seed-panel');
  const body = $('#seed-panel-body');
  body.innerHTML = '';

  const seeds = Object.keys(gameState.inventory).filter(id => gameState.inventory[id] > 0);

  if (seeds.length === 0) {
    body.innerHTML = '<p style="color:#78909c;text-align:center;padding:20px;">No seeds! Press <b>B</b> to open the Shop.</p>';
    panel.classList.remove('hidden');
    panel._plotIndex = plotIndex;
    return;
  }

  seeds.forEach(seedId => {
    const seed = getSeedData(seedId);
    if (!seed) return;
    const count = gameState.inventory[seedId];
    const opt = document.createElement('div');
    opt.className = 'seed-option';
    opt.innerHTML = `
      <span class="seed-emoji">${seed.emoji}</span>
      <div class="seed-info">
        <div class="seed-name">${seed.name}</div>
        <div class="seed-detail">${count}x | ${seed.growTime}s grow | Sells for ðŸª™${seed.sellPrice}</div>
      </div>
    `;
    opt.addEventListener('click', () => {
      plantSeed(plotIndex, seedId);
      closeSeedPanel();
    });
    body.appendChild(opt);
  });

  panel.classList.remove('hidden');
  panel._plotIndex = plotIndex;
}

function plantSeed(plotIndex, seedId) {
  if (!gameState.inventory[seedId] || gameState.inventory[seedId] <= 0) return;

  gameState.inventory[seedId]--;
  if (gameState.inventory[seedId] <= 0) delete gameState.inventory[seedId];

  gameState.plots[plotIndex] = {
    seedId: seedId,
    plantedAt: Date.now(),
    growTime: getSeedData(seedId).growTime,
    waterLevel: 100,
  };
  checkAchievement('first_sprout');

  showToast('ðŸŒ±', `Planted ${getSeedData(seedId).name}!`);
  updateHotbar();
  updatePlantMeshes();
  saveGame();
}

// â”€â”€â”€ Harvesting â”€â”€â”€
function harvestPlot(plotIndex) {
  const plotData = gameState.plots[plotIndex];
  if (!plotData) return;

  const seed = getSeedData(plotData.seedId);
  const rarity = seed.rarity || 'common';
  const rarityMult = rarity === 'legendary' ? 2 : rarity === 'rare' ? 1.5 : rarity === 'uncommon' ? 1.2 : 1;
  const sellPrice = Math.round(seed.sellPrice * rarityMult);

  gameState.coins += sellPrice;
  gameState.totalCoinsEarned += sellPrice;
  gameState.totalHarvested++;
  if (!gameState.harvestedTypes.includes(plotData.seedId)) {
    gameState.harvestedTypes.push(plotData.seedId);
  }
  gameState.plots[plotIndex] = null;

  const rarityLabel = rarity !== 'common' ? ` (${rarity})` : '';
  showToast('ðŸŽ‰', `Harvested ${seed.emoji} ${seed.name}${rarityLabel} â€” +ðŸª™${sellPrice}!`);
  spawnCoinFly();
  const particleCount = rarity === 'legendary' ? 16 : rarity === 'rare' ? 12 : 8;
  spawnParticles(window.innerWidth / 2, window.innerHeight / 2, seed.emoji, particleCount);

  // Achievement checks
  if (gameState.totalHarvested >= 10) checkAchievement('green_thumb');
  if (gameState.totalHarvested >= 50) checkAchievement('master_gardener');
  if (rarity === 'rare' || rarity === 'legendary') checkAchievement('rare_find');
  if (gameState.harvestedTypes.length >= 8) checkAchievement('variety_pack');
  if (gameState.totalCoinsEarned >= 500) checkAchievement('entrepreneur');
  if (gameState.coins >= 10000) checkAchievement('millionaire');

  // Check full garden
  const allPlanted = gameState.plots.every(p => p !== null);
  if (allPlanted) checkAchievement('full_garden');

  updateHUD();
  updateHotbar();
  updatePlantMeshes();
  saveGame();
}

// â”€â”€â”€ Seed Panel â”€â”€â”€
window.closeSeedPanel = function() {
  $('#seed-panel').classList.add('hidden');
};

// â”€â”€â”€ Shop â”€â”€â”€
function toggleShop() {
  const panel = $('#shop-panel');
  if (panel.classList.contains('hidden')) {
    openShop();
  } else {
    closeShop();
  }
}

function makeShopCard(seedId, seed) {
  const canAfford = gameState.coins >= seed.seedCost;
  const owned = gameState.inventory[seedId] || 0;

  const card = document.createElement('div');
  card.className = 'shop-card' + (seed.holiday ? ' shop-card-seasonal' : '');
  card.innerHTML = `
    <div class="shop-emoji">${seed.emoji}</div>
    <div class="shop-name">${seed.name}</div>
    ${seed.description ? `<div class="shop-desc">${seed.description}</div>` : ''}
    <div class="shop-stats">
      Grow: ${seed.growTime}s<br>
      Sell: ðŸª™${seed.sellPrice}<br>
      Owned: ${owned}
    </div>
    <button class="shop-btn" ${!canAfford ? 'disabled' : ''}>Buy ðŸª™${seed.seedCost}</button>
  `;

  card.querySelector('.shop-btn').addEventListener('click', () => {
    if (gameState.coins >= seed.seedCost) {
      gameState.coins -= seed.seedCost;
      gameState.inventory[seedId] = (gameState.inventory[seedId] || 0) + 1;
      showToast('ðŸ›’', `Bought ${seed.name} seed!`);
      updateHUD();
      updateHotbar();
      saveGame();
      openShop();
    }
  });

  return card;
}

function openShop() {
  if (document.pointerLockElement) document.exitPointerLock();
  closeAllPanels();

  const body = $('#shop-panel-body');
  body.innerHTML = '';

  // Seasonal seeds section
  const seasonal = getSeasonalSeeds();
  const holidayLabels = getActiveHolidayLabels();
  if (Object.keys(seasonal).length > 0) {
    const seasonHeader = document.createElement('div');
    seasonHeader.className = 'shop-section-header seasonal';
    seasonHeader.innerHTML = `${holidayLabels.join(' ')} <span class="seasonal-tag">Limited Time!</span>`;
    body.appendChild(seasonHeader);

    const seasonGrid = document.createElement('div');
    seasonGrid.className = 'shop-grid';
    for (const [seedId, seed] of Object.entries(seasonal)) {
      seasonGrid.appendChild(makeShopCard(seedId, seed));
    }
    body.appendChild(seasonGrid);

    const divider = document.createElement('hr');
    divider.className = 'shop-divider';
    body.appendChild(divider);
  }

  // Regular seeds
  const regularHeader = document.createElement('div');
  regularHeader.className = 'shop-section-header';
  regularHeader.textContent = 'ðŸŒ± Regular Seeds';
  body.appendChild(regularHeader);

  const grid = document.createElement('div');
  grid.className = 'shop-grid';
  SEED_LIST.forEach(seedId => {
    grid.appendChild(makeShopCard(seedId, getSeedData(seedId)));
  });
  body.appendChild(grid);

  $('#shop-panel').classList.remove('hidden');
}

window.closeShop = function() {
  $('#shop-panel').classList.add('hidden');
};

// â”€â”€â”€ Skin Shop (Wardrobe) â”€â”€â”€
function openWardrobe() {
  closeAllPanels();
  let panel = document.getElementById('wardrobe-panel');
  if (!panel) {
    panel = document.createElement('div');
    panel.id = 'wardrobe-panel';
    panel.className = 'game-panel';
    panel.innerHTML = `
      <div class="panel-header">
        <h2>ðŸ‘” Wardrobe</h2>
        <button class="panel-close" id="close-wardrobe">âœ•</button>
      </div>
      <div id="wardrobe-body" class="panel-body"></div>
    `;
    document.body.appendChild(panel);
    document.getElementById('close-wardrobe').addEventListener('click', closeWardrobe);
  }

  const body = document.getElementById('wardrobe-body');
  body.innerHTML = '';

  const profiles = getProfiles();
  const prof = profiles.find(p => p.id === activeProfileId);
  const currentSkin = (prof && prof.skin) || DEFAULT_SKIN;
  const unlocked = gameState.unlockedSkins || ['farmer'];

  Object.entries(CHARACTER_SKINS).forEach(([key, skin]) => {
    const isUnlocked = unlocked.includes(key);
    const isActive = currentSkin === key;
    const canAfford = gameState.coins >= skin.cost;

    const card = document.createElement('div');
    card.className = 'wardrobe-card' + (isActive ? ' active' : '') + (!isUnlocked ? ' locked' : '');

    let btnHtml;
    if (isActive) {
      btnHtml = '<button class="wardrobe-btn equipped" disabled>Wearing</button>';
    } else if (isUnlocked) {
      btnHtml = '<button class="wardrobe-btn equip">Wear</button>';
    } else {
      btnHtml = `<button class="wardrobe-btn buy" ${!canAfford ? 'disabled' : ''}>Buy \u{1fa99}${skin.cost.toLocaleString()}</button>`;
    }

    card.innerHTML = `
      <div class="wardrobe-emoji">${skin.emoji}</div>
      <div class="wardrobe-name">${skin.name}</div>
      ${!isUnlocked ? `<div class="wardrobe-cost">\u{1fa99} ${skin.cost.toLocaleString()}</div>` : ''}
      ${isUnlocked && !isActive ? '<div class="wardrobe-status">\u2705 Owned</div>' : ''}
      ${btnHtml}
    `;

    const btn = card.querySelector('.wardrobe-btn');
    if (!isActive && isUnlocked) {
      btn.addEventListener('click', () => {
        equipSkin(key);
        openWardrobe();
      });
    } else if (!isUnlocked && canAfford) {
      btn.addEventListener('click', () => {
        buySkin(key, skin.cost);
        openWardrobe();
      });
    }

    body.appendChild(card);
  });

  panel.classList.remove('hidden');
}

function closeWardrobe() {
  const panel = document.getElementById('wardrobe-panel');
  if (panel) panel.classList.add('hidden');
}

function buySkin(skinKey, cost) {
  if (gameState.coins < cost) return;
  gameState.coins -= cost;
  if (!gameState.unlockedSkins) gameState.unlockedSkins = ['farmer'];
  gameState.unlockedSkins.push(skinKey);
  equipSkin(skinKey);
  checkAchievement('fashion_forward');
  updateHUD();
  saveGame();
  showToast('\u{1f389}', 'Unlocked ' + CHARACTER_SKINS[skinKey].name + ' skin!');
}

function equipSkin(skinKey) {
  const profiles = getProfiles();
  const prof = profiles.find(p => p.id === activeProfileId);
  if (prof) {
    prof.skin = skinKey;
    saveProfiles(profiles);
  }
  buildPlayerModel();
  saveGame();
}


// â”€â”€â”€ Inventory â”€â”€â”€
function toggleInventory() {
  const panel = $('#inv-panel');
  if (panel.classList.contains('hidden')) {
    openInventory();
  } else {
    closeInventory();
  }
}

function openInventory() {
  if (document.pointerLockElement) document.exitPointerLock();
  closeAllPanels();

  const body = $('#inv-panel-body');
  body.innerHTML = '';

  const seeds = Object.keys(gameState.inventory).filter(id => gameState.inventory[id] > 0);

  if (seeds.length === 0) {
    body.innerHTML = '<p style="color:#78909c;text-align:center;padding:20px;">Inventory empty. Visit the Shop!</p>';
    $('#inv-panel').classList.remove('hidden');
    return;
  }

  const grid = document.createElement('div');
  grid.className = 'inv-grid';

  seeds.forEach(seedId => {
    const seed = getSeedData(seedId);
    if (!seed) return;
    const count = gameState.inventory[seedId];
    const item = document.createElement('div');
    item.className = 'inv-item';
    item.innerHTML = `
      <div class="inv-emoji">${seed.emoji}</div>
      <div class="inv-name">${seed.name}</div>
      <div class="inv-count">x${count}</div>
    `;
    grid.appendChild(item);
  });

  // Sell all harvested summary
  const sellInfo = document.createElement('div');
  sellInfo.style.cssText = 'margin-top:16px;text-align:center;font-size:14px;color:#90a4ae;';
  sellInfo.textContent = `Total seed types: ${seeds.length}`;

  body.appendChild(grid);
  body.appendChild(sellInfo);
  $('#inv-panel').classList.remove('hidden');
}

window.closeInventory = function() {
  $('#inv-panel').classList.add('hidden');
};

// â”€â”€â”€ Panels â”€â”€â”€
function isAnyPanelOpen() {
  const wp = document.getElementById('wardrobe-panel');
  const ap = document.getElementById('achieve-panel');
  const sp = document.getElementById('sell-panel');
  return !$('#seed-panel').classList.contains('hidden') ||
         !$('#shop-panel').classList.contains('hidden') ||
         !$('#inv-panel').classList.contains('hidden') ||
         (wp && !wp.classList.contains('hidden')) ||
         (ap && !ap.classList.contains('hidden')) ||
         (sp && !sp.classList.contains('hidden'));
}

function closeAllPanels() {
  $('#seed-panel').classList.add('hidden');
  $('#shop-panel').classList.add('hidden');
  $('#inv-panel').classList.add('hidden');
  closeWardrobe();
  const ap = document.getElementById('achieve-panel');
  if (ap) ap.classList.add('hidden');
  const sp = document.getElementById('sell-panel');
  if (sp) sp.classList.add('hidden');
}

// Close panels on overlay click
['seed-panel', 'shop-panel', 'inv-panel'].forEach(id => {
  $('#' + id).addEventListener('click', (e) => {
    if (e.target === $('#' + id)) {
      $('#' + id).classList.add('hidden');
    }
  });
});

// â”€â”€â”€ Hotbar â”€â”€â”€
function updateHotbar() {
  hotbarEl.innerHTML = '';
  const seeds = Object.keys(gameState.inventory).filter(id => gameState.inventory[id] > 0);

  // Show up to 9 seed types
  const slots = seeds.slice(0, 9);

  slots.forEach((seedId, i) => {
    const seed = getSeedData(seedId);
    if (!seed) return;
    const count = gameState.inventory[seedId];
    const slot = document.createElement('div');
    slot.className = 'hotbar-slot' + (i === gameState.selectedSlot ? ' selected' : '');
    slot.innerHTML = `
      <span class="slot-emoji">${seed.emoji}</span>
      <span class="slot-count">${count}</span>
    `;
    slot.addEventListener('click', () => selectHotbarSlot(i));
    hotbarEl.appendChild(slot);
  });

  // If no seeds, show empty
  if (slots.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'hotbar-slot';
    empty.innerHTML = '<span class="slot-emoji" style="opacity:0.3">ðŸŒ±</span>';
    hotbarEl.appendChild(empty);
  }
}

function selectHotbarSlot(index) {
  gameState.selectedSlot = index;
  updateHotbar();
}

// â”€â”€â”€ HUD â”€â”€â”€
function updateHUD() {
  coinAmountEl.textContent = gameState.coins.toLocaleString();
  const waterEl = document.getElementById('water-amount');
  if (waterEl) waterEl.textContent = Math.round(gameState.waterCan);
}

// â”€â”€â”€ Profile System â”€â”€â”€
const PROFILE_AVATARS = ['ðŸŒ»','ðŸŒµ','ðŸ„','ðŸŒ¸','ðŸŒ²','ðŸ¦Š','ðŸ¸','ðŸŒˆ','ðŸ€','ðŸ”¥','ðŸ','ðŸ¦‹','ðŸŒº','ðŸ‰','â­','ðŸ¢','ðŸŽ®','ðŸ§‘â€ðŸŒ¾'];

// â”€â”€â”€ Character Skins â”€â”€â”€
const CHARACTER_SKINS = {
  farmer: { name: 'Farmer', emoji: 'ðŸ§‘â€ðŸŒ¾', cost: 0 },
  ninja:  { name: 'Ninja',  emoji: 'ðŸ¥·',   cost: 1000 },
  sonic:  { name: 'Sonic',  emoji: 'ðŸ¦”',   cost: 1000 },
};
const DEFAULT_SKIN = 'farmer';

function getProfiles() {
  try { return JSON.parse(localStorage.getItem(PROFILES_KEY)) || []; } catch(e) { return []; }
}

function saveProfiles(profiles) {
  localStorage.setItem(PROFILES_KEY, JSON.stringify(profiles));
}

function migrateOldSave() {
  const old = localStorage.getItem('garden3d_save');
  if (!old) return;
  const profiles = getProfiles();
  if (profiles.length === 0) {
    const id = 'p_' + Date.now();
    profiles.push({ id, name: 'Player 1', avatar: 'ðŸŒ»' });
    saveProfiles(profiles);
    localStorage.setItem(SAVE_PREFIX + id, old);
  }
  localStorage.removeItem('garden3d_save');
}

function showProfileScreen() {
  // Remove existing if any
  const existing = document.getElementById('profile-screen');
  if (existing) existing.remove();

  migrateOldSave();
  const profiles = getProfiles();

  const overlay = document.createElement('div');
  overlay.id = 'profile-screen';
  overlay.innerHTML = `
    <div class="profile-container">
      <div class="logo-emoji">ðŸŒ±</div>
      <h1>Grow a Garden</h1>
      <p class="subtitle">Who's playing?</p>
      <div class="profile-grid" id="profile-grid"></div>
      <button class="profile-new-btn" id="new-profile-btn">+ New Gardener</button>
    </div>
  `;
  document.body.appendChild(overlay);

  const grid = document.getElementById('profile-grid');
  profiles.forEach(p => {
    const card = document.createElement('div');
    card.className = 'profile-card';
    card.innerHTML = `<span class="profile-avatar">${p.avatar}</span><span class="profile-name">${p.name}</span>`;
    card.addEventListener('click', () => selectProfile(p.id));

    // Long press / right-click to delete
    card.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if (confirm(`Delete ${p.name}'s garden? This cannot be undone!`)) {
        deleteProfile(p.id);
      }
    });
    grid.appendChild(card);
  });

  document.getElementById('new-profile-btn').addEventListener('click', showNewProfileModal);
}

function showNewProfileModal() {
  const profiles = getProfiles();
  if (profiles.length >= MAX_PROFILES) {
    alert('Maximum 10 profiles! Long-press a profile to delete one.');
    return;
  }

  const modal = document.createElement('div');
  modal.id = 'new-profile-modal';
  modal.innerHTML = `
    <div class="profile-modal-box">
      <h2>New Gardener</h2>
      <input type="text" id="profile-name-input" placeholder="Enter name..." maxlength="12" autofocus>
      <p style="margin:10px 0 5px;font-weight:bold;">Pick an avatar:</p>
      <div class="avatar-grid" id="avatar-grid"></div>
      <p style="margin:10px 0 5px;font-weight:bold;">Choose your character:</p>
      <div class="skin-grid" id="skin-grid"></div>
      <div style="margin-top:15px;display:flex;gap:10px;justify-content:center;">
        <button class="profile-modal-btn" id="create-profile-btn">Create</button>
        <button class="profile-modal-btn cancel" id="cancel-profile-btn">Cancel</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);

  let selectedAvatar = 'ðŸŒ»';
  const avatarGrid = document.getElementById('avatar-grid');
  PROFILE_AVATARS.forEach((emoji, i) => {
    const btn = document.createElement('span');
    btn.className = 'avatar-option' + (i === 0 ? ' selected' : '');
    btn.textContent = emoji;
    btn.addEventListener('click', () => {
      avatarGrid.querySelectorAll('.avatar-option').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      selectedAvatar = emoji;
    });
    avatarGrid.appendChild(btn);
  });

  let selectedSkin = DEFAULT_SKIN;
  const skinGrid = document.getElementById('skin-grid');
  Object.entries(CHARACTER_SKINS).forEach(([key, skin], i) => {
    const btn = document.createElement('span');
    btn.className = 'skin-option' + (i === 0 ? ' selected' : '');
    btn.innerHTML = `<span class="skin-emoji">${skin.emoji}</span><span class="skin-name">${skin.name}</span>`;
    btn.addEventListener('click', () => {
      skinGrid.querySelectorAll('.skin-option').forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      selectedSkin = key;
    });
    skinGrid.appendChild(btn);
  });

  document.getElementById('create-profile-btn').addEventListener('click', () => {
    const name = document.getElementById('profile-name-input').value.trim();
    if (!name) { document.getElementById('profile-name-input').focus(); return; }
    const id = 'p_' + Date.now();
    const profiles = getProfiles();
    profiles.push({ id, name, avatar: selectedAvatar, skin: selectedSkin });
    saveProfiles(profiles);
    modal.remove();
    selectProfile(id);
  });

  document.getElementById('cancel-profile-btn').addEventListener('click', () => modal.remove());
  document.getElementById('profile-name-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') document.getElementById('create-profile-btn').click();
  });
  setTimeout(() => document.getElementById('profile-name-input').focus(), 50);
}

function deleteProfile(id) {
  let profiles = getProfiles();
  profiles = profiles.filter(p => p.id !== id);
  saveProfiles(profiles);
  localStorage.removeItem(SAVE_PREFIX + id);
  showProfileScreen();
}

function selectProfile(id) {
  activeProfileId = id;
  const profileScreen = document.getElementById('profile-screen');
  if (profileScreen) profileScreen.remove();
  const modal = document.getElementById('new-profile-modal');
  if (modal) modal.remove();

  // Show profile badge
  const profiles = getProfiles();
  const p = profiles.find(pr => pr.id === id);
  if (p) showProfileBadge(p);

  // Now init the game
  initGame();
}

function showProfileBadge(profile) {
  let badge = document.getElementById('profile-badge');
  if (!badge) {
    badge = document.createElement('div');
    badge.id = 'profile-badge';
    document.body.appendChild(badge);
  }
  badge.innerHTML = `<span class="badge-avatar">${profile.avatar}</span><span class="badge-name">${profile.name}</span><button class="badge-switch" id="switch-profile-btn">â†©</button>`;
  document.getElementById('switch-profile-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    // Reset game state
    if (started) saveGame();
    started = false;
    // Clean up Three.js
    if (renderer) {
      renderer.domElement.remove();
      renderer.dispose();
      renderer = null;
    }
    scene = null; camera = null;
    plotMeshes = []; cloudMeshes = [];
    animating = false;
    document.getElementById('start-screen').style.display = '';
    badge.remove();
    activeProfileId = null;
    showProfileScreen();
  });
}

// â”€â”€â”€ Save / Load â”€â”€â”€
function saveGame() {
  if (!activeProfileId) return;
  try {
    const data = {
      coins: gameState.coins,
      inventory: gameState.inventory,
      plots: gameState.plots,
      selectedSlot: gameState.selectedSlot,
      unlockedSkins: gameState.unlockedSkins,
      waterCan: gameState.waterCan,
      achievements: gameState.achievements,
      totalCoinsEarned: gameState.totalCoinsEarned,
      totalHarvested: gameState.totalHarvested,
      harvestedTypes: gameState.harvestedTypes,
      decorations: gameState.decorations,
      savedAt: Date.now(),
    };
    localStorage.setItem(getSaveKey(), JSON.stringify(data));
  } catch(e) { /* ignore */ }
}

function loadGame() {
  if (!activeProfileId) return false;
  try {
    const raw = localStorage.getItem(getSaveKey());
    if (!raw) return false;
    const data = JSON.parse(raw);
    gameState.coins = data.coins || 100;
    gameState.inventory = data.inventory || { daisy: 3 };
    gameState.plots = data.plots || [];
    gameState.selectedSlot = data.selectedSlot || 0;
    gameState.unlockedSkins = data.unlockedSkins || ['farmer'];
    gameState.waterCan = data.waterCan != null ? data.waterCan : 100;
    gameState.achievements = data.achievements || [];
    gameState.totalCoinsEarned = data.totalCoinsEarned || 0;
    gameState.totalHarvested = data.totalHarvested || 0;
    gameState.harvestedTypes = data.harvestedTypes || [];
    gameState.decorations = data.decorations || [];

    // Ensure 16 plots
    while (gameState.plots.length < PLOT_GRID * PLOT_GRID) {
      gameState.plots.push(null);
    }

    // Migrate: add waterLevel to existing plots
    gameState.plots.forEach(plot => {
      if (plot && plot.waterLevel == null) plot.waterLevel = 100;
    });

    // Calculate offline growth
    if (data.savedAt) {
      let readyCount = 0;
      gameState.plots.forEach(plot => {
        if (plot) {
          if (getEffectiveProgress(plot) >= 1) readyCount++;
        }
      });
      if (readyCount > 0) {
        showToast('ðŸŒ…', `Welcome back! ${readyCount} plant${readyCount > 1 ? 's' : ''} ready to harvest!`);
      }
    }

    return true;
  } catch(e) {
    return false;
  }
}

// â”€â”€â”€ Achievement System â”€â”€â”€
const ACHIEVEMENTS = {
  first_sprout:    { name: 'First Sprout',      emoji: 'ðŸŒ±', desc: 'Plant your first seed' },
  green_thumb:     { name: 'Green Thumb',        emoji: 'ðŸŒ»', desc: 'Harvest 10 plants' },
  master_gardener: { name: 'Master Gardener',    emoji: 'ðŸ†', desc: 'Harvest 50 plants' },
  entrepreneur:    { name: 'Entrepreneur',       emoji: 'ðŸ’°', desc: 'Earn 500 coins total' },
  rare_find:       { name: 'Rare Find',          emoji: 'ðŸ’Ž', desc: 'Harvest a Rare or Legendary plant' },
  fashion_forward: { name: 'Fashion Forward',    emoji: 'ðŸŽ­', desc: 'Buy a skin from the wardrobe' },
  full_garden:     { name: 'Full Garden',        emoji: 'ðŸ“¦', desc: 'Fill all 16 plots at once' },
  variety_pack:    { name: 'Variety Pack',       emoji: 'ðŸŒˆ', desc: 'Grow 8 different seed types' },
  millionaire:     { name: 'Millionaire',        emoji: 'ðŸ’µ', desc: 'Have 10,000 coins at once' },
  dog_lover:       { name: 'Dog Lover',          emoji: 'ðŸ•', desc: 'Pet Buddy the dog' },
};

function checkAchievement(id) {
  if (!gameState.achievements) gameState.achievements = [];
  if (gameState.achievements.includes(id)) return;
  if (!ACHIEVEMENTS[id]) return;
  gameState.achievements.push(id);
  const a = ACHIEVEMENTS[id];
  showToast('ðŸ…', `Achievement: ${a.emoji} ${a.name}!`);
  spawnParticles(window.innerWidth / 2, 100, 'â­', 12);
  saveGame();
}

function openAchievements() {
  closeAllPanels();
  let panel = document.getElementById('achieve-panel');
  if (!panel) {
    panel = document.createElement('div');
    panel.id = 'achieve-panel';
    panel.className = 'game-panel';
    panel.innerHTML = `
      <div class="panel-header">
        <h2>ðŸ… Achievements</h2>
        <button class="panel-close" id="close-achieve">âœ•</button>
      </div>
      <div id="achieve-body" class="panel-body"></div>
    `;
    document.body.appendChild(panel);
    document.getElementById('close-achieve').addEventListener('click', () => {
      panel.classList.add('hidden');
    });
  }

  const body = document.getElementById('achieve-body');
  body.innerHTML = '';
  const unlocked = gameState.achievements || [];

  Object.entries(ACHIEVEMENTS).forEach(([id, a]) => {
    const got = unlocked.includes(id);
    const card = document.createElement('div');
    card.className = 'achieve-card' + (got ? ' unlocked' : '');
    card.innerHTML = `
      <span class="achieve-emoji">${got ? a.emoji : 'ðŸ”’'}</span>
      <div class="achieve-info">
        <div class="achieve-name">${a.name}</div>
        <div class="achieve-desc">${a.desc}</div>
      </div>
      ${got ? '<span class="achieve-check">âœ…</span>' : ''}
    `;
    body.appendChild(card);
  });

  const count = document.createElement('div');
  count.style.cssText = 'text-align:center;margin-top:12px;color:#90a4ae;font-size:13px;';
  count.textContent = `${unlocked.length} / ${Object.keys(ACHIEVEMENTS).length} unlocked`;
  body.appendChild(count);

  panel.classList.remove('hidden');
}

// â”€â”€â”€ Day/Night Cycle Update â”€â”€â”€
function updateDayNight(dt) {
  dayTime += dt / DAY_CYCLE_DURATION;
  if (dayTime >= 1) dayTime -= 1;

  // Calculate phase: 0-0.15 dawn, 0.15-0.65 day, 0.65-0.8 dusk, 0.8-1 night
  let skyColor, fogColor, sunIntensity, ambIntensity;
  const nightSky = 0x0a0e2a;
  const daySky = 0x87CEEB;
  const dawnSky = 0xffa07a;
  const duskSky = 0x8B5CF6;

  if (dayTime < 0.15) {
    // Night to dawn
    const t = dayTime / 0.15;
    skyColor = lerpColor(nightSky, dawnSky, t);
    fogColor = skyColor;
    sunIntensity = 0.2 + t * 0.6;
    ambIntensity = 0.15 + t * 0.25;
  } else if (dayTime < 0.3) {
    // Dawn to day
    const t = (dayTime - 0.15) / 0.15;
    skyColor = lerpColor(dawnSky, daySky, t);
    fogColor = skyColor;
    sunIntensity = 0.8 + t * 0.4;
    ambIntensity = 0.4 + t * 0.1;
  } else if (dayTime < 0.65) {
    // Full day
    skyColor = daySky;
    fogColor = daySky;
    sunIntensity = 1.2;
    ambIntensity = 0.5;
  } else if (dayTime < 0.8) {
    // Day to dusk
    const t = (dayTime - 0.65) / 0.15;
    skyColor = lerpColor(daySky, duskSky, t);
    fogColor = skyColor;
    sunIntensity = 1.2 - t * 0.6;
    ambIntensity = 0.5 - t * 0.2;
  } else {
    // Dusk to night
    const t = (dayTime - 0.8) / 0.2;
    skyColor = lerpColor(duskSky, nightSky, t);
    fogColor = skyColor;
    sunIntensity = 0.6 - t * 0.4;
    ambIntensity = 0.3 - t * 0.15;
  }

  // Apply weather modifiers
  if (currentWeather === 'rainy') {
    skyColor = lerpColor(skyColor, 0x4a5568, 0.5);
    fogColor = skyColor;
    sunIntensity *= 0.6;
  } else if (currentWeather === 'cloudy') {
    skyColor = lerpColor(skyColor, 0x9ca3af, 0.3);
    fogColor = skyColor;
    sunIntensity *= 0.8;
  }

  if (scene) {
    scene.background = new THREE.Color(skyColor);
    scene.fog.color = new THREE.Color(fogColor);
  }
  if (sunLight) {
    sunLight.intensity = sunIntensity;
    // Sun position orbits based on time
    const sunAngle = dayTime * Math.PI * 2 - Math.PI / 2;
    sunLight.position.set(Math.cos(sunAngle) * 20, Math.sin(sunAngle) * 20 + 5, 8);
  }
  if (ambientLight) ambientLight.intensity = ambIntensity;

  // Update time indicator in HUD
  const timeEl = document.getElementById('time-indicator');
  if (timeEl) {
    const isNight = dayTime > 0.8 || dayTime < 0.15;
    timeEl.textContent = isNight ? 'ðŸŒ™' : 'â˜€ï¸';
  }
  const weatherEl = document.getElementById('weather-indicator');
  if (weatherEl) {
    weatherEl.textContent = currentWeather === 'rainy' ? 'ðŸŒ§ï¸' : currentWeather === 'cloudy' ? 'â˜ï¸' : '';
  }
}

// â”€â”€â”€ Weather System â”€â”€â”€
function updateWeather(dt) {
  weatherTimer -= dt;
  if (weatherTimer <= 0) {
    const roll = Math.random();
    if (roll < 0.5) currentWeather = 'sunny';
    else if (roll < 0.8) currentWeather = 'cloudy';
    else currentWeather = 'rainy';
    weatherTimer = 120 + Math.random() * 180; // 2-5 min between changes

    if (currentWeather === 'rainy') {
      showToast('ðŸŒ§ï¸', 'It\'s raining! Your plants are getting watered!');
      buildRainParticles();
    } else {
      removeRainParticles();
      if (currentWeather === 'sunny') showToast('â˜€ï¸', 'The sun is shining!');
    }
  }

  // Rain waters plants
  if (currentWeather === 'rainy') {
    gameState.plots.forEach(plot => {
      if (plot) {
        plot.waterLevel = Math.min(100, (plot.waterLevel || 0) + dt * 0.5);
      }
    });
    updateRainParticles(dt);
  }
}

function buildRainParticles() {
  removeRainParticles();
  rainDrops = [];
  const rainMat = new THREE.MeshBasicMaterial({ color: 0x6699cc, transparent: true, opacity: 0.6 });
  for (let i = 0; i < 80; i++) {
    const drop = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.3, 0.05), rainMat);
    drop.position.set(
      (Math.random() - 0.5) * 40,
      5 + Math.random() * 15,
      (Math.random() - 0.5) * 40
    );
    scene.add(drop);
    rainDrops.push(drop);
  }
}

function removeRainParticles() {
  rainDrops.forEach(d => scene.remove(d));
  rainDrops = [];
}

function updateRainParticles(dt) {
  rainDrops.forEach(drop => {
    drop.position.y -= dt * 12;
    if (drop.position.y < 0) {
      drop.position.y = 10 + Math.random() * 10;
      drop.position.x = playerPos.x + (Math.random() - 0.5) * 30;
      drop.position.z = playerPos.z + (Math.random() - 0.5) * 30;
    }
  });
}

// â”€â”€â”€ Watering System â”€â”€â”€
function waterPlot(plotIndex) {
  if (gameState.waterCan <= 0) {
    showToast('ðŸ’§', 'Watering can is empty! Find the well to refill.');
    return;
  }
  const plot = gameState.plots[plotIndex];
  if (!plot) return;
  if (plot.waterLevel >= 100) {
    showToast('ðŸ’§', 'This plant is fully watered!');
    return;
  }
  plot.waterLevel = Math.min(100, plot.waterLevel + 30);
  gameState.waterCan = Math.max(0, gameState.waterCan - 10);
  showToast('ðŸ’§', `Watered! Plant: ${Math.round(plot.waterLevel)}% | Can: ${Math.round(gameState.waterCan)}%`);
  updateHUD();
  saveGame();
}

function refillWaterCan() {
  gameState.waterCan = 100;
  showToast('ðŸš°', 'Watering can refilled!');
  updateHUD();
}

const WELL_POS = { x: 10, z: -2 };
const WELL_INTERACT_DIST = 3;
let nearWell = false;
let wellModel = null;

function buildWell() {
  wellModel = new THREE.Group();
  const stoneMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
  const woodMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const waterMat = new THREE.MeshLambertMaterial({ color: 0x4FC3F7, transparent: true, opacity: 0.7 });

  // Stone base (ring)
  const base = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 1.5), stoneMat);
  base.position.y = 0.4;
  base.castShadow = true;
  wellModel.add(base);

  // Inner water
  const water = new THREE.Mesh(new THREE.BoxGeometry(1, 0.1, 1), waterMat);
  water.position.y = 0.75;
  wellModel.add(water);

  // Roof supports
  const pole1 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 1.8, 0.12), woodMat);
  pole1.position.set(-0.6, 1.7, 0);
  pole1.castShadow = true;
  wellModel.add(pole1);
  const pole2 = new THREE.Mesh(new THREE.BoxGeometry(0.12, 1.8, 0.12), woodMat);
  pole2.position.set(0.6, 1.7, 0);
  pole2.castShadow = true;
  wellModel.add(pole2);

  // Roof
  const roof = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1.2), woodMat);
  roof.position.y = 2.65;
  roof.castShadow = true;
  wellModel.add(roof);

  // Bucket
  const bucket = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.25), woodMat);
  bucket.position.set(0, 1.5, 0);
  wellModel.add(bucket);

  wellModel.position.set(WELL_POS.x, 0, WELL_POS.z);
  scene.add(wellModel);
}

// â”€â”€â”€ Water depletion over time â”€â”€â”€
function updateWaterLevels(dt) {
  gameState.plots.forEach(plot => {
    if (!plot) return;
    if (plot.waterLevel == null) plot.waterLevel = 100;
    if (plot.pausedGrowthTime == null) plot.pausedGrowthTime = 0;

    if (plot.waterLevel > 0) {
      plot.waterLevel = Math.max(0, plot.waterLevel - dt * 0.2); // lose ~1 per 5 seconds
    } else {
      // Dry â€” accumulate paused time so effective growth doesn't advance
      plot.pausedGrowthTime += dt;
    }
  });
}

function getEffectiveProgress(plotData) {
  const elapsed = (Date.now() - plotData.plantedAt) / 1000;
  const paused = plotData.pausedGrowthTime || 0;
  return Math.min((elapsed - paused) / plotData.growTime, 1);
}

// â”€â”€â”€ Pet Dog: Buddy â”€â”€â”€
function buildDog() {
  if (dogModel) scene.remove(dogModel);
  dogModel = new THREE.Group();

  const bodyColor = 0xCD853F;
  const darkColor = 0x8B6914;
  const bellyColor = 0xF5DEB3;
  const noseColor = 0x333333;

  // Body
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.35, 0.3), new THREE.MeshLambertMaterial({ color: bodyColor }));
  body.position.set(0, 0.35, 0);
  body.castShadow = true;
  dogModel.add(body);

  // Belly
  const belly = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.25), new THREE.MeshLambertMaterial({ color: bellyColor }));
  belly.position.set(0, 0.2, 0);
  dogModel.add(belly);

  // Head
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), new THREE.MeshLambertMaterial({ color: bodyColor }));
  head.position.set(0.35, 0.5, 0);
  head.castShadow = true;
  dogModel.add(head);

  // Snout
  const snout = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.15), new THREE.MeshLambertMaterial({ color: bellyColor }));
  snout.position.set(0.45, 0.45, 0);
  dogModel.add(snout);

  // Nose
  const nose = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.06), new THREE.MeshLambertMaterial({ color: noseColor }));
  nose.position.set(0.52, 0.47, 0);
  dogModel.add(nose);

  // Eyes
  const eyeMat = new THREE.MeshLambertMaterial({ color: noseColor });
  const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.05, 0.04), eyeMat);
  eyeL.position.set(0.43, 0.55, 0.1);
  dogModel.add(eyeL);
  const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.05, 0.04), eyeMat);
  eyeR.position.set(0.43, 0.55, -0.1);
  dogModel.add(eyeR);

  // Ears (floppy)
  const earMat = new THREE.MeshLambertMaterial({ color: darkColor });
  const earL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.06), earMat);
  earL.position.set(0.3, 0.55, 0.15);
  earL.rotation.z = 0.3;
  dogModel.add(earL);
  const earR = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.06), earMat);
  earR.position.set(0.3, 0.55, -0.15);
  earR.rotation.z = 0.3;
  dogModel.add(earR);

  // Legs
  const legMat = new THREE.MeshLambertMaterial({ color: bodyColor });
  const legGeo = new THREE.BoxGeometry(0.08, 0.18, 0.08);
  const fl = new THREE.Mesh(legGeo, legMat); fl.position.set(0.2, 0.09, 0.12); dogModel.add(fl);
  const fr = new THREE.Mesh(legGeo, legMat); fr.position.set(0.2, 0.09, -0.12); dogModel.add(fr);
  const bl = new THREE.Mesh(legGeo, legMat); bl.position.set(-0.2, 0.09, 0.12); dogModel.add(bl);
  const br = new THREE.Mesh(legGeo, legMat); br.position.set(-0.2, 0.09, -0.12); dogModel.add(br);

  // Tail
  const tail = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.2, 0.06), new THREE.MeshLambertMaterial({ color: bodyColor }));
  tail.position.set(-0.35, 0.5, 0);
  tail.rotation.z = -0.5;
  dogModel.add(tail);

  dogModel.userData = { tail, fl, fr, bl, br };
  dogModel.position.set(dogPos.x, 0, dogPos.z);
  dogModel.scale.set(1.3, 1.3, 1.3);
  scene.add(dogModel);
}

function updateDog(dt, time) {
  if (!dogModel) return;

  // Dog bark timer
  dogBarkTimer -= dt;
  if (dogBarkTimer <= 0) {
    dogBarkTimer = 30 + Math.random() * 30;
    showToast('ðŸ•', 'Woof!');
  }

  // Follow player or wander
  const dx = playerPos.x - dogPos.x;
  const dz = playerPos.z - dogPos.z;
  const distToPlayer = Math.sqrt(dx * dx + dz * dz);

  if (distToPlayer > 6) {
    // Run to catch up
    dogTargetPos.set(playerPos.x - 2, 0, playerPos.z - 1);
  } else if (distToPlayer < 2) {
    // Too close, don't move
    dogWanderTimer -= dt;
    if (dogWanderTimer <= 0) {
      dogWanderTimer = 3 + Math.random() * 5;
      dogTargetPos.set(
        playerPos.x + (Math.random() - 0.5) * 8,
        0,
        playerPos.z + (Math.random() - 0.5) * 8
      );
    }
  } else {
    dogWanderTimer -= dt;
    if (dogWanderTimer <= 0) {
      dogWanderTimer = 3 + Math.random() * 5;
      dogTargetPos.set(
        playerPos.x + (Math.random() - 0.5) * 6,
        0,
        playerPos.z + (Math.random() - 0.5) * 6
      );
    }
  }

  // Move toward target
  const tdx = dogTargetPos.x - dogPos.x;
  const tdz = dogTargetPos.z - dogPos.z;
  const tdist = Math.sqrt(tdx * tdx + tdz * tdz);
  const dogMoving = tdist > 0.3;

  if (dogMoving) {
    const speed = distToPlayer > 6 ? DOG_SPEED * 1.8 : DOG_SPEED;
    dogPos.x += (tdx / tdist) * speed * dt;
    dogPos.z += (tdz / tdist) * speed * dt;

    // Face direction
    dogModel.rotation.y = Math.atan2(tdx, tdz) - Math.PI / 2;

    // Walk animation
    dogWalkCycle += dt * 12;
    const swing = Math.sin(dogWalkCycle) * 0.3;
    const parts = dogModel.userData;
    if (parts.fl) parts.fl.rotation.x = swing;
    if (parts.fr) parts.fr.rotation.x = -swing;
    if (parts.bl) parts.bl.rotation.x = -swing;
    if (parts.br) parts.br.rotation.x = swing;
  } else {
    // Idle â€” wag tail
    const parts = dogModel.userData;
    if (parts.tail) parts.tail.rotation.x = Math.sin(time * 6) * 0.4;
    // Reset legs
    if (parts.fl) parts.fl.rotation.x = 0;
    if (parts.fr) parts.fr.rotation.x = 0;
    if (parts.bl) parts.bl.rotation.x = 0;
    if (parts.br) parts.br.rotation.x = 0;
  }

  // Keep in bounds
  const bound = WORLD_SIZE / 2 - 2;
  dogPos.x = clamp(dogPos.x, -bound, bound);
  dogPos.z = clamp(dogPos.z, -bound, bound);

  dogModel.position.set(dogPos.x, 0, dogPos.z);

  // Dog label
  const labelEl = document.getElementById('dog-label');
  if (labelEl && camera) {
    const labelPos = new THREE.Vector3(dogPos.x, 1.5, dogPos.z);
    labelPos.project(camera);
    const hw = window.innerWidth / 2;
    const hh = window.innerHeight / 2;
    const sx = labelPos.x * hw + hw;
    const sy = -(labelPos.y * hh) + hh;
    if (labelPos.z < 1 && labelPos.z > 0) {
      labelEl.style.left = sx + 'px';
      labelEl.style.top = sy + 'px';
      labelEl.classList.toggle('visible', distToPlayer < 8);
    } else {
      labelEl.classList.remove('visible');
    }
  }
}

function petDog() {
  showToast('â¤ï¸', 'Buddy loves you!');
  spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 'â¤ï¸', 8);
  checkAchievement('dog_lover');
}

// â”€â”€â”€ Ambient Creatures â”€â”€â”€
function buildButterflies() {
  const colors = [0xFF69B4, 0xFFD700, 0x87CEEB, 0xFF6347, 0xADFF2F, 0xEE82EE];
  for (let i = 0; i < 6; i++) {
    const g = new THREE.Group();
    const wingMat = new THREE.MeshLambertMaterial({ color: colors[i % colors.length], transparent: true, opacity: 0.8 });
    const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.01, 0.12), wingMat);
    wingL.position.set(-0.08, 0, 0);
    g.add(wingL);
    const wingR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.01, 0.12), wingMat);
    wingR.position.set(0.08, 0, 0);
    g.add(wingR);
    const bodyM = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.03, 0.1), new THREE.MeshLambertMaterial({ color: 0x333333 }));
    g.add(bodyM);

    g.position.set(
      (Math.random() - 0.5) * 20,
      1 + Math.random() * 2,
      (Math.random() - 0.5) * 20
    );
    g.userData = {
      wingL, wingR,
      baseX: g.position.x,
      baseZ: g.position.z,
      phase: Math.random() * Math.PI * 2,
      speed: 0.5 + Math.random() * 0.5,
    };
    scene.add(g);
    butterflies.push(g);
  }
}

function updateButterflies(time) {
  const isNight = dayTime > 0.8 || dayTime < 0.15;
  butterflies.forEach(b => {
    b.visible = !isNight;
    if (isNight) return;

    const d = b.userData;
    b.position.x = d.baseX + Math.sin(time * d.speed + d.phase) * 3;
    b.position.z = d.baseZ + Math.cos(time * d.speed * 0.7 + d.phase) * 3;
    b.position.y = 1.5 + Math.sin(time * 2 + d.phase) * 0.5;
    b.rotation.y = time * d.speed;

    // Wing flap
    d.wingL.rotation.z = Math.sin(time * 15 + d.phase) * 0.5;
    d.wingR.rotation.z = -Math.sin(time * 15 + d.phase) * 0.5;
  });
}

function buildFireflies() {
  const glowMat = new THREE.MeshBasicMaterial({ color: 0xFFFF44, transparent: true, opacity: 0.8 });
  for (let i = 0; i < 20; i++) {
    const ff = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.06), glowMat.clone());
    ff.position.set(
      (Math.random() - 0.5) * 30,
      0.5 + Math.random() * 3,
      (Math.random() - 0.5) * 30
    );
    ff.userData = {
      baseX: ff.position.x,
      baseY: ff.position.y,
      baseZ: ff.position.z,
      phase: Math.random() * Math.PI * 2,
    };
    ff.visible = false;
    scene.add(ff);
    fireflies.push(ff);
  }
}

function updateFireflies(time) {
  const isNight = dayTime > 0.8 || dayTime < 0.15;
  fireflies.forEach(ff => {
    ff.visible = isNight;
    if (!isNight) return;
    const d = ff.userData;
    ff.position.x = d.baseX + Math.sin(time * 0.5 + d.phase) * 2;
    ff.position.y = d.baseY + Math.sin(time * 0.8 + d.phase * 2) * 0.5;
    ff.position.z = d.baseZ + Math.cos(time * 0.4 + d.phase) * 2;
    ff.material.opacity = 0.4 + Math.sin(time * 3 + d.phase) * 0.4;
  });
}

function buildBirds() {
  const birdMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
  for (let i = 0; i < 4; i++) {
    const g = new THREE.Group();
    // V shape
    const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.02, 0.08), birdMat);
    wingL.position.set(-0.15, 0, 0);
    wingL.rotation.z = 0.3;
    g.add(wingL);
    const wingR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.02, 0.08), birdMat);
    wingR.position.set(0.15, 0, 0);
    wingR.rotation.z = -0.3;
    g.add(wingR);

    g.position.set(
      -30 + Math.random() * 10,
      12 + Math.random() * 5,
      (Math.random() - 0.5) * 40
    );
    g.userData = { speed: 3 + Math.random() * 2, wingL, wingR };
    scene.add(g);
    birds.push(g);
  }
}

function updateBirds(dt, time) {
  const isNight = dayTime > 0.8 || dayTime < 0.15;
  birds.forEach(b => {
    b.visible = !isNight;
    if (isNight) return;
    b.position.x += b.userData.speed * dt;
    if (b.position.x > 35) {
      b.position.x = -35;
      b.position.z = (Math.random() - 0.5) * 40;
      b.position.y = 12 + Math.random() * 5;
    }
    // Wing flap
    b.userData.wingL.rotation.z = 0.3 + Math.sin(time * 8) * 0.2;
    b.userData.wingR.rotation.z = -0.3 - Math.sin(time * 8) * 0.2;
  });
}

// â”€â”€â”€ Selling System (in shop) â”€â”€â”€
function openSellPanel() {
  closeAllPanels();
  let panel = document.getElementById('sell-panel');
  if (!panel) {
    panel = document.createElement('div');
    panel.id = 'sell-panel';
    panel.className = 'panel-overlay';
    panel.innerHTML = `
      <div class="panel">
        <div class="panel-header">
          <h2>ðŸ’° Sell to Shlomo</h2>
          <button class="panel-close" id="close-sell">âœ•</button>
        </div>
        <div class="panel-body" id="sell-panel-body"></div>
      </div>
    `;
    document.body.appendChild(panel);
    document.getElementById('close-sell').addEventListener('click', () => panel.classList.add('hidden'));
    panel.addEventListener('click', (e) => { if (e.target === panel) panel.classList.add('hidden'); });
  }

  const body = document.getElementById('sell-panel-body');
  body.innerHTML = '';

  // Bonus item (changes based on time)
  const allSeeds = Object.keys(SEEDS);
  const bonusIdx = Math.floor(Date.now() / 86400000) % allSeeds.length;
  const bonusSeedId = allSeeds[bonusIdx];

  const items = Object.keys(gameState.inventory).filter(id => gameState.inventory[id] > 0);
  if (items.length === 0) {
    body.innerHTML = '<p style="color:#78909c;text-align:center;padding:20px;">Nothing to sell! Harvest some plants first.</p>';
    panel.classList.remove('hidden');
    return;
  }

  // Bonus banner
  const bonusSeed = getSeedData(bonusSeedId);
  if (bonusSeed) {
    const banner = document.createElement('div');
    banner.className = 'sell-bonus';
    banner.innerHTML = `ðŸ”¥ <b>HOT TODAY:</b> ${bonusSeed.emoji} ${bonusSeed.name} sells for 1.5x!`;
    body.appendChild(banner);
  }

  const grid = document.createElement('div');
  grid.className = 'shop-grid';

  items.forEach(seedId => {
    const seed = getSeedData(seedId);
    if (!seed) return;
    const count = gameState.inventory[seedId];
    const rarity = seed.rarity || 'common';
    const rarityMult = rarity === 'legendary' ? 2 : rarity === 'rare' ? 1.5 : rarity === 'uncommon' ? 1.2 : 1;
    const isBonus = seedId === bonusSeedId;
    const price = Math.round(seed.sellPrice * rarityMult * (isBonus ? 1.5 : 1));

    const card = document.createElement('div');
    card.className = 'shop-card';
    card.innerHTML = `
      <div class="shop-emoji">${seed.emoji}</div>
      <div class="shop-name" style="color:${getRarityColor(rarity)}">${seed.name}${isBonus ? ' ðŸ”¥' : ''}</div>
      <div class="shop-stats">
        Owned: ${count}<br>
        Value: ðŸª™${price} each
      </div>
      <button class="shop-btn sell-one-btn">Sell 1 â€” ðŸª™${price}</button>
      ${count > 1 ? `<button class="shop-btn sell-all-btn" style="margin-top:4px;background:linear-gradient(135deg,#FF9800,#E65100);">Sell All (${count}) â€” ðŸª™${price * count}</button>` : ''}
    `;

    card.querySelector('.sell-one-btn').addEventListener('click', () => {
      sellItem(seedId, 1, price);
      openSellPanel(); // refresh
    });
    const sellAllBtn = card.querySelector('.sell-all-btn');
    if (sellAllBtn) {
      sellAllBtn.addEventListener('click', () => {
        const cnt = gameState.inventory[seedId] || 0;
        sellItem(seedId, cnt, price);
        openSellPanel();
      });
    }

    grid.appendChild(card);
  });

  body.appendChild(grid);
  panel.classList.remove('hidden');
}

function sellItem(seedId, count, priceEach) {
  const available = gameState.inventory[seedId] || 0;
  const actual = Math.min(count, available);
  if (actual <= 0) return;

  const total = priceEach * actual;
  gameState.inventory[seedId] -= actual;
  if (gameState.inventory[seedId] <= 0) delete gameState.inventory[seedId];
  gameState.coins += total;
  gameState.totalCoinsEarned += total;

  const seed = getSeedData(seedId);
  showToast('ðŸ’°', `Sold ${actual}x ${seed.emoji} ${seed.name} for ðŸª™${total}!`);
  spawnCoinFly();

  if (gameState.totalCoinsEarned >= 500) checkAchievement('entrepreneur');
  if (gameState.coins >= 10000) checkAchievement('millionaire');

  updateHUD();
  updateHotbar();
  saveGame();
}

function getRarityColor(rarity) {
  switch(rarity) {
    case 'legendary': return '#FFD700';
    case 'rare': return '#A855F7';
    case 'uncommon': return '#3B82F6';
    default: return '#fff';
  }
}

// â”€â”€â”€ Animate Plant Bobs â”€â”€â”€
function animatePlants(time) {
  for (let i = 0; i < plotMeshes.length; i++) {
    const pm = plotMeshes[i];
    const plotData = gameState.plots[i];
    if (!plotData || !pm.plantMesh) continue;

    const isReady = getEffectiveProgress(plotData) >= 1;

    if (isReady && pm.plantMesh) {
      // Bob up and down
      pm.plantMesh.position.y = Math.sin(time * 3 + i) * 0.05;
      pm.plantMesh.rotation.y = Math.sin(time * 2 + i * 0.5) * 0.05;
    }

    // Glow pulse
    if (pm.glowMesh) {
      pm.glowMesh.material.opacity = 0.2 + Math.sin(time * 4 + i) * 0.15;
    }
  }
}

// â”€â”€â”€ Cloud animation â”€â”€â”€
function animateClouds(dt) {
  cloudMeshes.forEach(cloud => {
    cloud.position.x += dt * 0.3;
    if (cloud.position.x > 30) cloud.position.x = -30;
  });
}

// â”€â”€â”€ Main Game Loop â”€â”€â”€
function animate() {
  if (!animating || !renderer) return;
  requestAnimationFrame(animate);

  const dt = Math.min(clock.getDelta(), 0.1);
  const time = clock.getElapsedTime();

  if (!started) return;

  updatePlayer(dt);
  updateInteraction();
  animatePlants(time);
  animateClouds(dt);
  updateDayNight(dt);
  updateWeather(dt);
  updateWaterLevels(dt);
  updateDog(dt, time);
  updateButterflies(time);
  updateFireflies(time);
  updateBirds(dt, time);

  // Shlomo idle + floating label
  if (shopkeeperModel && camera) {
    // Floating label position
    const labelEl = document.getElementById('shopkeeper-label');
    if (labelEl) {
      const labelPos = new THREE.Vector3(SHOPKEEPER_POS.x, 3.4, SHOPKEEPER_POS.z);
      labelPos.project(camera);
      const hw = window.innerWidth / 2;
      const hh = window.innerHeight / 2;
      const sx = labelPos.x * hw + hw;
      const sy = -(labelPos.y * hh) + hh;
      if (labelPos.z < 1 && labelPos.z > 0) {
        labelEl.style.left = sx + 'px';
        labelEl.style.top = sy + 'px';
        const dist = Math.sqrt((playerPos.x - SHOPKEEPER_POS.x)**2 + (playerPos.z - SHOPKEEPER_POS.z)**2);
        labelEl.classList.toggle('visible', dist < 12);
      } else {
        labelEl.classList.remove('visible');
      }
    }
  }

  // Periodic plant mesh update (every 2 seconds for growth changes)
  if (Math.floor(time * 0.5) !== Math.floor((time - dt) * 0.5)) {
    updatePlantMeshes();
  }

  // Auto-save
  autoSaveTimer += dt;
  if (autoSaveTimer >= AUTO_SAVE_SEC) {
    autoSaveTimer = 0;
    saveGame();
  }

  renderer.render(scene, camera);
}

// â”€â”€â”€ Save on exit / background â”€â”€â”€
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden' && started) saveGame();
});
window.addEventListener('beforeunload', () => { if (started) saveGame(); });
window.addEventListener('pagehide', () => { if (started) saveGame(); });

// â”€â”€â”€ Start Game â”€â”€â”€
function startGame() {
  started = true;
  startScreen.style.display = 'none';

  // Third-person: no pointer lock needed
}

// â”€â”€â”€ Init Game (after profile selected) â”€â”€â”€
function initGame() {
  // Reset game state
  gameState = {
    coins: 100,
    inventory: { daisy: 3, sunflower: 2 },
    plots: [],
    selectedSlot: 0,
    unlockedSkins: ['farmer'],
    waterCan: 100,
    achievements: [],
    totalCoinsEarned: 0,
    totalHarvested: 0,
    harvestedTypes: [],
    decorations: [],
  };
  plotMeshes = [];
  cloudMeshes = [];
  autoSaveTimer = 0;
  started = false;

  playerPos = new THREE.Vector3(0, 0, 8);
  playerGroundY = 0;
  walkCycle = 0;
  isMoving = false;
  yaw = 0; pitch = 0;

  // Reset ambient state
  butterflies = [];
  birds = [];
  fireflies = [];
  rainDrops = [];
  dogModel = null;
  wellModel = null;
  dayTime = 0.25;
  currentWeather = 'sunny';
  weatherTimer = 60 + Math.random() * 120;

  initScene();
  initLighting();
  buildWorld();
  buildPlayerModel();
  buildShopkeeper();
  buildWell();
  buildDog();
  buildButterflies();
  buildFireflies();
  buildBirds();

  const loaded = loadGame();
  if (!loaded) {
    initPlots();
  }

  buildGardenPlots();
  updatePlantMeshes();
  initControls();
  updateHUD();
  updateHotbar();

  // Wardrobe button
  const wBtn = document.getElementById('wardrobe-btn');
  if (wBtn && !wBtn._bound) {
    wBtn.addEventListener('click', () => openWardrobe());
    wBtn._bound = true;
  }

  // Achievements button
  const aBtn = document.getElementById('achieve-btn');
  if (aBtn && !aBtn._bound) {
    aBtn.addEventListener('click', () => openAchievements());
    aBtn._bound = true;
  }

  // Sell button
  const sellBtn = document.getElementById('sell-btn');
  if (sellBtn && !sellBtn._bound) {
    sellBtn.addEventListener('click', () => openSellPanel());
    sellBtn._bound = true;
  }

  // Touch watering
  const touchWater = document.getElementById('touch-water');
  if (touchWater && !touchWater._bound) {
    touchWater.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (interactTarget !== null) waterPlot(interactTarget);
    }, {passive: false});
    touchWater._bound = true;
  }

  // Show start screen
  startScreen.style.display = '';
  if (!startBtnBound) {
    startBtn.addEventListener('click', startGame);
    startBtnBound = true;
  }

  if (!animating) {
    animating = true;
    animate();
  }
}

// â”€â”€â”€ Init (show profile screen) â”€â”€â”€
function init() {
  showProfileScreen();
}

// Boot
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

})();
